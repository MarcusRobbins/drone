

# File Contents

## live_mvp\environment_windows_cpu.yml

```yaml

name: live-mvp-cpu
channels:
  - conda-forge
dependencies:
  - python=3.11
  - pip
  - pip:
      - jax
      - optax

```

## live_mvp\environment_wsl_gpu.yml

```yaml

name: live-mvp-cuda
channels:
  - conda-forge
dependencies:
  - python=3.11
  - pip
  - pip:
      - "jax[cuda12]"
      - optax

```

## live_mvp\pyproject.toml

```toml

[build-system]
requires = ["setuptools>=61"]
build-backend = "setuptools.build_meta"

[project]
name = "live_mvp"
version = "0.1.0"
description = "Minimal live-map + policy demo (hash-grid, anchor + compass)"
readme = "README.md"
requires-python = ">=3.10"
authors = [{name = "live_mvp authors"}]
dependencies = []

[tool.setuptools.packages.find]
where = ["src"]

```

## live_mvp\pytest.ini

```ini
[pytest]
addopts = -q

```

## live_mvp\README.md

```markdown

# live_mvp — Minimal live-map + policy (hash-grid, anchor + compass)

This is a tiny, end-to-end differentiable multi-drone scanning demo. The **only** ground-truth usage is to synthesize depth; **everything** the policy sees and all rewards come from a **live map** learned online:

- `Gθ(x)`: geometry SDF (via a tiny MLP on a **multi‑resolution hash‑grid** encoder)
- `Qη(x)`: exposure/coverage ∈ [0,1] (same encoder family)

**Policy inputs (no learned featurizer):**
- **Anchor‑lattice** samples of `[clipped SDF, exposure]` at a small 3D grid around the drone (captures vertical structure / altitude cues).
- An **“unseen compass”**: per‑direction info‑gain–like potentials from the live map, plus a summarized 3‑vector pointing toward unseen space.

**Differentiable where it matters:** Gradients flow from reward → pose via soft visibility; we **do not** backprop through live-map parameters (map updates are SGD steps with stop‑grad exposure).

---

## Install & run

> **Windows + GPU note:** Native Windows GPU wheels for JAX are not supported; use **WSL2 (Ubuntu)** for GPU, or install the CPU-only environment on Windows. See `install_wsl_gpu.sh` and `install_windows_cpu.bat` in the `scripts/` folder.

```bash
# In WSL2 (GPU) or Linux:
bash scripts/install_wsl_gpu.sh
# Then
python -m live_mvp.train_live
```

On Windows CPU-only:
```bat
scripts\install_windows_cpu.bat
# Then (in Anaconda Prompt or VS Code with that env selected):
python -m live_mvp.train_live
```

---

## What’s inside

- `env_gt.py` : Analytic GT world (plane + sphere + box) & sphere-traced depth.
- `live_map.py`: Hash‑grid encoders + tiny MLPs for `Gθ` and `Qη`; **masked** online updates.
- `render.py`  : Soft visibility, expected hit, incidence, reward terms.
- `dyn.py`     : Simple differentiable kinematics & quaternion utilities.
- `policy.py`  : Non‑learned **anchor‑lattice** and **unseen compass** features, and a tiny MLP for the policy.
- `train_live.py`: Fused `train_step` (JIT/GPU); rollout loop that updates the live map, computes reward **from the live map**, and trains the policy.

```

## live_mvp\run-tests.bat

```bat
@echo off
call conda activate live-mvp-jax
python -m pip install -U pytest numpy
set PYTHONPATH=%CD%\src
pytest

```

## live_mvp\run-tests.sh

```bash
#!/usr/bin/env bash
set -euo pipefail
source "$(conda info --base)/etc/profile.d/conda.sh"
conda activate live-mvp-jax
python -m pip install -U pytest numpy
export PYTHONPATH="$(pwd)/src:${PYTHONPATH:-}"
pytest

```

## live_mvp\run-train-local.bat

```bat
@echo off
setlocal
REM Run without installing package: add src to PYTHONPATH
set PYTHONPATH=%CD%\src
python -m live_mvp.train_live

```

## live_mvp\run-train-local.sh

```bash
#!/usr/bin/env bash
set -euo pipefail
export PYTHONPATH="$(pwd)/src:${PYTHONPATH:-}"
python -m live_mvp.train_live

```

## live_mvp\scripts\install_windows_cpu.bat

```bat
@echo off
setlocal enabledelayedexpansion

echo === live_mvp :: Windows (CPU-only) install ===

REM --- Ensure we're in the project root (must contain pyproject.toml)
if not exist "pyproject.toml" (
  echo [ERROR] pyproject.toml not found. Run this script from the project root.
  exit /b 1
)

REM --- Check that Conda is available
where conda >nul 2>&1
if errorlevel 1 (
  echo [ERROR] Conda not found. Please open an "Anaconda Prompt" or install Miniconda/Anaconda.
  exit /b 1
)

REM --- Remove any existing env (ignore errors if it doesn't exist)
echo Removing existing env 'live-mvp-jax' if present...
call conda env remove -y -n live-mvp-jax >nul 2>&1

REM --- Create fresh env
echo Creating env 'live-mvp-jax'...
call conda create -y -n live-mvp-jax python=3.11 pip
if errorlevel 1 (
  echo [ERROR] Failed to create conda env.
  exit /b 1
)

REM --- Activate env
call conda activate live-mvp-jax
if errorlevel 1 (
  echo [ERROR] Failed to activate conda env 'live-mvp-jax'.
  exit /b 1
)

REM --- Upgrade pip tooling
python -m pip install --upgrade pip setuptools wheel
if errorlevel 1 (
  echo [ERROR] Failed to upgrade pip/setuptools/wheel.
  exit /b 1
)

REM --- Install JAX (CPU) + Optax
REM On Windows, GPU wheels aren't supported; this installs CPU-only jax/jaxlib.
python -m pip install -U jax jaxlib optax
if errorlevel 1 (
  echo [WARN] 'pip install jax jaxlib optax' failed. Trying fallback 'pip install jax optax'...
  python -m pip install -U jax optax
  if errorlevel 1 (
    echo [ERROR] Failed to install JAX. See https://github.com/google/jax#installation
    exit /b 1
  )
)

REM --- Editable install of this package
python -m pip install -e .
if errorlevel 1 (
  echo [ERROR] Editable install failed. Ensure 'pyproject.toml' is in this folder.
  exit /b 1
)

REM --- Verify JAX (and that the env has the package)
if exist "verify_jax.py" (
  echo.
  echo === Verifying JAX devices ===
  python verify_jax.py
) else (
  echo.
  echo [INFO] 'verify_jax.py' not found; quick inline check:
  python - <<PY
import jax, importlib, sys
print("JAX:", jax.__version__)
print("Devices:", jax.devices())
m = importlib.import_module("live_mvp")
print("Imported live_mvp from:", m.__file__)
PY
)

echo.
echo Done. In VS Code, select the interpreter named: live-mvp-jax
```

## live_mvp\scripts\install_wsl_gpu.sh

```bash

#!/usr/bin/env bash
set -euo pipefail

ENV_NAME="live-mvp-cuda"

# Make sure we run in the repo root (where pyproject.toml lives)
REPO_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$REPO_DIR"

# Ensure conda exists; if not, install Mambaforge lightweight
if ! command -v conda >/dev/null 2>&1; then
  echo "[info] conda not found; installing Mambaforge in $HOME/mambaforge ..."
  curl -L -o /tmp/mambaforge.sh https://github.com/conda-forge/miniforge/releases/latest/download/Mambaforge-Linux-x86_64.sh
  bash /tmp/mambaforge.sh -b -p "$HOME/mambaforge"
  eval "$("$HOME/mambaforge/bin/conda" shell.bash hook)"
  conda init bash
  echo "[info] Restart your shell if conda command is not recognized."
fi

# Load conda shell functions
eval "$(conda shell.bash hook)"

echo "[info] Creating conda env ${ENV_NAME} ..."
conda create -y -n "${ENV_NAME}" python=3.11 pip

echo "[info] Installing JAX (CUDA12) + optax via pip ..."
conda run -n "${ENV_NAME}" python -m pip install --upgrade pip
# JAX CUDA wheels (Linux only)
conda run -n "${ENV_NAME}" python -m pip install -U "jax[cuda12]" optax

echo "[info] Installing live_mvp (editable) ..."
conda run -n "${ENV_NAME}" python -m pip install -e .

echo "[info] Verifying JAX detects the GPU ..."
conda run -n "${ENV_NAME}" python scripts/verify_jax.py

cat <<EOF

[OK] Environment '${ENV_NAME}' is ready.

Activate it with:
  conda activate ${ENV_NAME}

Run the demo:
  python -m live_mvp.train_live

In VS Code:
  1) Install the "WSL" extension.
  2) Open this folder in WSL (Remote: WSL).
  3) Select interpreter: ${ENV_NAME}

EOF

```

## live_mvp\scripts\verify_jax.py

```python

import jax, jax.numpy as jnp

print("JAX version:", jax.__version__)
try:
    import jaxlib
    print("jaxlib version:", jaxlib.__version__)
except Exception as e:
    print("jaxlib not importable:", e)

x = jnp.arange(9, dtype=jnp.float32).reshape(3,3)
y = x @ x.T
print("devices:", jax.devices())
print("platform:", jax.default_backend())
print("matmul result (sum):", float(y.sum()))

# Simple GPU check
gpu = any(d.platform == "gpu" for d in jax.devices())
print("GPU available:", gpu)

```

## live_mvp\src\live_mvp\dyn.py

```python

from typing import NamedTuple
import jax, jax.numpy as jnp

class State(NamedTuple):
    p: jnp.ndarray; v: jnp.ndarray; q: jnp.ndarray; w: jnp.ndarray

class DynCfg(NamedTuple):
    dt: float = 0.05
    drag_v: float = 0.05
    drag_w: float = 0.02
    a_max: float = 3.5
    w_max: float = 1.2

def quat_mul(q, r):
    w1,x1,y1,z1 = q; w2,x2,y2,z2 = r
    return jnp.array([w1*w2 - x1*x2 - y1*y2 - z1*z2,
                      w1*x2 + x1*w2 + y1*z2 - z1*y2,
                      w1*y2 - x1*z2 + y1*w2 + z1*x2,
                      w1*z2 + x1*y2 - y1*x2 + z1*w2])

def quat_normalize(q): 
    return q/(jnp.linalg.norm(q)+1e-9)

def R_from_q(q):
    w,x,y,z = q
    xx,yy,zz = x*x,y*y,z*z; wx,wy,wz = w*x,w*y,w*z; xy,xz,yz = x*y,x*z,y*z
    return jnp.array([[1-2*(yy+zz), 2*(xy-wz),   2*(xz+wy)],
                      [2*(xy+wz),   1-2*(xx+zz), 2*(yz-wx)],
                      [2*(xz-wy),   2*(yz+wx),   1-2*(xx+yy)]])

def clamp_u(u, cfg: DynCfg):
    a = jnp.clip(u[:3], -cfg.a_max, cfg.a_max)
    w = jnp.clip(u[3:], -cfg.w_max, cfg.w_max)
    return jnp.concatenate([a,w])

def step(st: State, u_raw: jnp.ndarray, cfg: DynCfg) -> State:
    u = clamp_u(u_raw, cfg)
    a, w_cmd = u[:3], u[3:]
    v = st.v + cfg.dt * (a - cfg.drag_v*st.v)
    p = st.p + cfg.dt * v
    dq = 0.5 * quat_mul(st.q, jnp.array([0., *w_cmd]))
    q = quat_normalize(st.q + cfg.dt * dq)
    w = (1.0 - cfg.drag_w*cfg.dt) * w_cmd
    return State(p,v,q,w)

def body_rays_world(q, rays_body):
    return (R_from_q(q) @ rays_body.T).T

```

## live_mvp\src\live_mvp\env_gt.py

```python
import jax, jax.numpy as jnp

def smin(a, b, k=8.0):
    return -jnp.log(jnp.exp(-k*a) + jnp.exp(-k*b) + 1e-12) / k

def sd_box(x, h):
    q = jnp.abs(x) - h
    return jnp.linalg.norm(jnp.maximum(q, 0.0), axis=-1) + jnp.minimum(jnp.max(q), 0.0)

def phi_gt(x):
    # Ground plane z=0 (positive above)
    phi_plane = x[2]
    # Sphere
    c_sph = jnp.array([3.0, 0.0, 1.0]); r_sph = 1.0
    phi_sphere = jnp.linalg.norm(x - c_sph) - r_sph
    # Box
    c_box = jnp.array([1.6, -1.4, 0.7]); he = jnp.array([0.6, 0.6, 0.8])
    phi_box = sd_box(x - c_box, he)
    return smin(smin(phi_plane, phi_sphere), phi_box)

def raycast_depth_gt(o, d, t_max=12.0, eps=1e-3, iters=64):
    """Sphere tracing on ground-truth SDF to synthesize a depth measurement."""
    # ----- FIX: normalize d so scaling doesn't change the result -----
    o = jnp.asarray(o)
    d = jnp.asarray(d)
    d = d / (jnp.linalg.norm(d) + 1e-12)
    # ----------------------------------------------------------------

    def body(carry, _):
        t, hit = carry
        x = o + t * d
        dt = jnp.clip(phi_gt(x), 1e-3, 0.5)
        t_new = t + dt
        hit_new = jnp.where(jnp.abs(phi_gt(x)) < eps, 1.0, hit)
        return (t_new, hit_new), t_new

    (t_final, hitflag), _ = jax.lax.scan(body, (0.0, 0.0), None, length=iters)
    t_meas = jnp.where((hitflag > 0.5) & (t_final <= t_max), t_final, jnp.nan)
    return t_meas

```

## live_mvp\src\live_mvp\live_map.py

```python

from typing import NamedTuple
import jax, jax.numpy as jnp, optax

# ---------------------------
# Multi-resolution hash-grid
# ---------------------------

class HashCfg(NamedTuple):
    L: int = 12          # levels
    F: int = 2           # features per level
    N_min: int = 16      # min grid res
    N_max: int = 512     # max grid res
    T: int = 1 << 15     # table size per level (power of two)
    lb: jnp.ndarray = jnp.array([-6., -6.,  0.])   # world AABB lower
    ub: jnp.ndarray = jnp.array([ 6.,  6.,  4.])   # world AABB upper

HASH_CFG = HashCfg()

def _level_res(l: int, cfg: HashCfg):
    g = l / max(cfg.L - 1, 1)
    return jnp.floor(cfg.N_min * (cfg.N_max / cfg.N_min) ** g).astype(jnp.int32)

def _hash_ijk(ijk, T):
    # 3D mix hash (Instant-NGP-style primes)
    ijk = ijk.astype(jnp.uint32)
    x, y, z = ijk[...,0], ijk[...,1], ijk[...,2]
    h = (x * jnp.uint32(0x9E3779B1) ^
         y * jnp.uint32(0x85EBCA77) ^
         z * jnp.uint32(0xC2B2AE3D))
    return (h & (jnp.uint32(T) - jnp.uint32(1))).astype(jnp.int32)

def _encode_point(tables, x, cfg: HashCfg):
    # Normalize to [0,1]^3 within AABB
    u = (x - cfg.lb) / (cfg.ub - cfg.lb + 1e-9)
    u = jnp.clip(u, 0.0, 1.0)
    feats = []
    for l in range(cfg.L):
        N = _level_res(l, cfg)
        u_grid = u * (N - 1).astype(jnp.float32)
        i0 = jnp.floor(u_grid).astype(jnp.int32)
        t = (u_grid - i0.astype(jnp.float32))
        i0 = jnp.clip(i0, 0, N - 2)
        emb = jnp.zeros((cfg.F,))
        for dz in (0,1):
            for dy in (0,1):
                for dx in (0,1):
                    corner = i0 + jnp.array([dx, dy, dz], dtype=jnp.int32)
                    wxyz = ((t[0] if dx else 1.0 - t[0]) *
                            (t[1] if dy else 1.0 - t[1]) *
                            (t[2] if dz else 1.0 - t[2]))
                    hid = _hash_ijk(corner, HASH_CFG.T)
                    emb_l = tables[l][hid]  # (F,)
                    emb = emb + wxyz * emb_l
        feats.append(emb)
    return jnp.concatenate(feats, axis=0)  # (L*F,)

v_encode = jax.vmap(_encode_point, in_axes=(None,0,None))

def init_hash_tables(key, cfg: HashCfg):
    keys = jax.random.split(key, cfg.L)
    return tuple(jax.random.normal(k, (cfg.T, cfg.F)) * 1e-4 for k in keys)

# ---------------------------
# Tiny MLP
# ---------------------------

def init_mlp(key, in_dim, hidden, out_dim):
    keys = jax.random.split(key, len(hidden)+1)
    params=[]
    prev = in_dim
    for k, h in zip(keys[:-1], hidden):
        W = jax.random.normal(k, (prev, h)) * (1.0/jnp.sqrt(prev))
        b = jnp.zeros((h,)); params.append((W,b)); prev=h
    k = keys[-1]
    W = jax.random.normal(k, (prev, out_dim)) * (1.0/jnp.sqrt(prev))
    b = jnp.zeros((out_dim,)); params.append((W,b))
    return tuple(params)

def mlp_apply(params, x):
    for W,b in params[:-1]:
        x = jax.nn.relu(x @ W + b)
    W,b = params[-1]
    return x @ W + b

# ---------------------------
# States and fields
# ---------------------------

class GeomParams(NamedTuple):
    tables: tuple  # tuple of (T,F) arrays per level
    mlp:    tuple  # MLP weights

class ExpoParams(NamedTuple):
    tables: tuple
    mlp:    tuple

class GeomState(NamedTuple):
    theta: GeomParams
    opt:   optax.OptState

class ExpoState(NamedTuple):
    eta: ExpoParams
    opt: optax.OptState

class MapState(NamedTuple):
    geom: GeomState
    expo: ExpoState

_G_OPT_TX = optax.adam(1e-3)
_E_OPT_TX = optax.adam(1e-3)

def init_live_map(key):
    k1,k2,k3,k4 = jax.random.split(key, 4)
    tables_g = init_hash_tables(k1, HASH_CFG)
    tables_e = init_hash_tables(k2, HASH_CFG)
    in_dim   = HASH_CFG.L * HASH_CFG.F
    mlp_g    = init_mlp(k3, in_dim, [64,64], 1)
    mlp_e    = init_mlp(k4, in_dim, [64,64], 1)
    theta    = GeomParams(tables=tables_g, mlp=mlp_g)
    eta      = ExpoParams(tables=tables_e, mlp=mlp_e)
    return MapState(GeomState(theta, _G_OPT_TX.init(theta)),
                    ExpoState(eta,   _E_OPT_TX.init(eta)))

def G_phi(x, theta: GeomParams):
    z = _encode_point(theta.tables, x, HASH_CFG)
    return mlp_apply(theta.mlp, z)[0]

def Q_expo(x, eta: ExpoParams):
    z = _encode_point(eta.tables, x, HASH_CFG)
    return jax.nn.sigmoid(mlp_apply(eta.mlp, z)[0])

v_G = jax.vmap(G_phi, in_axes=(0, None))
v_Q = jax.vmap(Q_expo, in_axes=(0, None))

# ---------------------------
# Online updates (masked, JIT-safe)
# ---------------------------

def update_geom(mapstate: MapState,
                hits_xyz, hits_mask,           # (R,3), (R,)
                frees_xyz, frees_mask):        # (R,S,3), (R,S)
    theta, opt = mapstate.geom

    def loss_fn(params: GeomParams):
        mu = 0.2
        # hits
        l_hit, eik = 0.0, 0.0
        if hits_xyz.shape[0] > 0:
            g_hits = v_G(hits_xyz, params)                      # (R,)
            w_hits = hits_mask.astype(jnp.float32)
            l_hit  = (w_hits * (g_hits**2)).sum() / (w_hits.sum() + 1e-6)
            # eikonal near hits (masked)
            def grad_norm(x): return jnp.linalg.norm(jax.grad(lambda xx: G_phi(xx, params))(x))
            gn = jax.vmap(grad_norm)(hits_xyz)
            eik = ((w_hits * (gn - 1.0)**2).sum() / (w_hits.sum() + 1e-6))

        # free space
        l_free = 0.0
        if frees_xyz.size > 0:
            xs = frees_xyz.reshape(-1,3)                        # (R*S,3)
            wm = frees_mask.reshape(-1).astype(jnp.float32)     # (R*S,)
            g_free = v_G(xs, params)
            l_free = (wm * (g_free - mu)**2).sum() / (wm.sum() + 1e-6)

        return l_hit + 0.5*l_free + 0.1*eik

    g = jax.grad(loss_fn)(theta)
    updates, opt2 = _G_OPT_TX.update(g, opt, theta)
    theta2 = optax.apply_updates(theta, updates)
    return MapState(GeomState(theta2, opt2), mapstate.expo)

def update_expo(mapstate: MapState,
                seen_xyz, seen_w):            # (R,S,3), (R,S)
    eta, opt = mapstate.expo

    def loss_fn(params: ExpoParams):
        if seen_xyz.size == 0:
            return 0.0
        xs = seen_xyz.reshape(-1,3)
        w  = seen_w.reshape(-1).astype(jnp.float32)
        p  = v_Q(xs, params)
        eps = 1e-6
        bce = -(w * jnp.log(p + eps)).sum() / (w.sum() + 1e-6)
        return bce

    g = jax.grad(loss_fn)(eta)
    updates, opt2 = _E_OPT_TX.update(g, opt, eta)
    eta2 = optax.apply_updates(eta, updates)
    return MapState(mapstate.geom, ExpoState(eta2, opt2))

```

## live_mvp\src\live_mvp\play_interactive.py

```python
"""
Interactive viewer for live_mvp:
- Keyboard control of one drone (body-frame accelerations + yaw rate).
- 3 synchronized views:
  (1) Ground-truth φ_gt cross-section with φ=0 contour and drone pose.
  (2) Drone "camera" depth image (fast discretized ray marcher).
  (3) Live-map reconstruction: Qη(x) heatmap + learned φ̂≈0 contour.

Keys:
  W/S  : forward/back (body-x)
  A/D  : left/right   (body-y)
  R/F  : up/down      (body-z)
  Q/E  : yaw left/right (body-z angular rate)
  Shift: boost (2x accel & yaw rate)
  Space: brake (zero velocity)
  C    : recenter slice z to drone z
  P    : pause/resume
  Esc  : quit
"""

import time
from dataclasses import dataclass

import jax
import jax.numpy as jnp
import numpy as np
import matplotlib.pyplot as plt

from .dyn import State, DynCfg, step, R_from_q
from .env_gt import phi_gt, raycast_depth_gt
from .live_map import (
    init_live_map, update_geom, update_expo, MapState, v_Q, v_G, HASH_CFG
)

# ---------------------------
# Small helpers
# ---------------------------

def camera_dirs_body(n_az=40, n_el=30, fov_az_deg=80., fov_el_deg=45.):
    """Grid of unit directions in the body frame covering a rectangular FOV."""
    az = jnp.linspace(-jnp.deg2rad(fov_az_deg)/2, jnp.deg2rad(fov_az_deg)/2, n_az)
    el = jnp.linspace(-jnp.deg2rad(fov_el_deg)/2, jnp.deg2rad(fov_el_deg)/2, n_el)
    A, E = jnp.meshgrid(az, el, indexing='xy')
    x = jnp.cos(E) * jnp.cos(A)
    y = jnp.cos(E) * jnp.sin(A)
    z = jnp.sin(E)
    D = jnp.stack([x, y, z], axis=-1)
    D = D / (jnp.linalg.norm(D, axis=-1, keepdims=True) + 1e-9)
    return D.reshape(-1, 3), (int(n_el), int(n_az))


def fast_raycast_depth_grid(o, D, t0=0.2, t1=12.0, S=96, eps=0.02):
    """
    Fast, discretized raycaster for visualization.
    o: (3,), D: (M,3). Returns t: (M,) with NaN for misses.
    """
    ts = jnp.linspace(t0, t1, S)  # (S,)
    xs = o[None, None, :] + ts[:, None, None] * D[None, :, :]  # (S,M,3)
    xs_flat = xs.reshape(-1, 3)
    phi = jax.vmap(phi_gt)(xs_flat).reshape(S, -1)              # (S,M)
    # Consider 'hit' when φ <= eps
    hit_mask = phi <= eps
    any_hit = hit_mask.any(axis=0)                               # (M,)
    first_idx = jnp.argmax(hit_mask, axis=0)                     # (M,), 0 if none
    t = ts[first_idx]
    t = jnp.where(any_hit, t, jnp.nan)
    return t


def grid_xy(lb, ub, res, z_plane):
    xs = jnp.linspace(lb[0], ub[0], res)
    ys = jnp.linspace(lb[1], ub[1], res)
    X, Y = jnp.meshgrid(xs, ys, indexing='xy')
    XY = jnp.stack([X, Y], axis=-1)  # (res,res,2)
    pts = jnp.concatenate([XY, jnp.full((res, res, 1), z_plane)], axis=-1).reshape(-1, 3)
    return xs, ys, X, Y, pts


@dataclass
class Controls:
    w: bool = False; s: bool = False
    a: bool = False; d: bool = False
    r: bool = False; f: bool = False
    q: bool = False; e: bool = False
    boost: bool = False
    brake: bool = False
    paused: bool = False
    recenter_slice: bool = False
    quit: bool = False


# ---------------------------
# Interactive App
# ---------------------------

class InteractiveApp:
    def __init__(self):
        # World bounds from HASH_CFG for visuals
        self.lb = np.array(HASH_CFG.lb)
        self.ub = np.array(HASH_CFG.ub)

        # Sim & map state
        key = jax.random.PRNGKey(0)
        self.mapstate: MapState = init_live_map(key)

        # One drone state
        p0 = jnp.array([0., 0., 1.6])
        v0 = jnp.zeros(3)
        q0 = jnp.array([1., 0., 0., 0.])   # identity
        w0 = jnp.zeros(3)
        self.state = State(p0, v0, q0, w0)
        self.cfg = DynCfg(dt=0.05)

        # Camera dirs & shapes
        self.cam_dirs_body, self.cam_shape = camera_dirs_body(n_az=40, n_el=30)
        self.cam_S = 96  # samples for fast camera

        # Mapping update subsample (coarse rays)
        self.map_dirs_body, _ = camera_dirs_body(n_az=24, n_el=3, fov_az_deg=100., fov_el_deg=40.)

        # Visualization grids
        self.slice_z = float(self.state.p[2])   # start at drone z
        self.res = 128
        self.xs, self.ys, self.Xm, self.Ym, self.slice_pts = grid_xy(HASH_CFG.lb, HASH_CFG.ub, self.res, self.slice_z)

        # Matplotlib figure
        self.fig, (self.ax_gt, self.ax_cam, self.ax_live) = plt.subplots(1, 3, figsize=(13.5, 4.5))
        self.fig.canvas.manager.set_window_title("live_mvp :: interactive")

        # Initialize images/contours
        self.im_cam = self.ax_cam.imshow(np.zeros(self.cam_shape), origin='lower', aspect='auto',
                                         extent=[-40, 40, -22.5, 22.5])
        self.ax_cam.set_title("Drone view (depth, deg az x deg el)")
        self.ax_cam.set_xlabel("azimuth (deg)"); self.ax_cam.set_ylabel("elevation (deg)")

        self.im_live = self.ax_live.imshow(np.zeros((self.res, self.res)),
                                           extent=[self.xs[0], self.xs[-1], self.ys[0], self.ys[-1]],
                                           origin='lower', interpolation='nearest', vmin=0.0, vmax=1.0)
        self.ax_live.set_title("Reconstruction Qη (coverage) @ z-slice")
        self.ax_live.set_xlabel("x"); self.ax_live.set_ylabel("y")
        self.cont_live = None  # learned φ̂≈0 contour

        self.im_gt = self.ax_gt.imshow(np.zeros((self.res, self.res)),
                                       extent=[self.xs[0], self.xs[-1], self.ys[0], self.ys[-1]],
                                       origin='lower', interpolation='nearest')
        self.ax_gt.set_title("Ground truth φ_gt @ z-slice")
        self.ax_gt.set_xlabel("x"); self.ax_gt.set_ylabel("y")
        self.cont_gt = None

        # Drone pose artists in GT panel
        p0_np = np.array(p0)
        self.pose_quiver = self.ax_gt.quiver([p0_np[0]], [p0_np[1]], [0.0], [0.0],
                                             scale=10, width=0.004, color='k')

        # Status text
        self.txt = self.fig.text(0.02, 0.95, "", ha='left', va='top')

        # Controls
        self.ctrl = Controls()

        # Keyboard bindings
        self.fig.canvas.mpl_connect('key_press_event', self.on_key)
        self.fig.canvas.mpl_connect('key_release_event', self.on_key)

        # First render
        self.update_all(bootstrap=True)

    # -------- utils --------

    def _clear_contour(self, cs):
        """Remove all artists for a contour set across Matplotlib versions."""
        if cs is None:
            return
        try:
            if hasattr(cs, "collections"):
                for coll in cs.collections:
                    try:
                        coll.remove()
                    except Exception:
                        pass
                return
            if hasattr(cs, "artists"):
                for art in cs.artists:
                    try:
                        art.remove()
                    except Exception:
                        pass
                return
            if hasattr(cs, "lines"):
                for ln in cs.lines:
                    try:
                        ln.remove()
                    except Exception:
                        pass
                return
            if hasattr(cs, "remove"):
                cs.remove()
        except Exception:
            pass

    # -------- keyboard --------

    def on_key(self, event):
        name = event.key.lower() if event.key is not None else ""
        down = (event.name == 'key_press_event')

        if name in ('shift',):
            self.ctrl.boost = down
        elif name == ' ':
            self.ctrl.brake = down
        elif name == 'w':
            self.ctrl.w = down
        elif name == 's':
            self.ctrl.s = down
        elif name == 'a':
            self.ctrl.a = down
        elif name == 'd':
            self.ctrl.d = down
        elif name == 'r':
            self.ctrl.r = down
        elif name == 'f':
            self.ctrl.f = down
        elif name == 'q':
            self.ctrl.q = down
        elif name == 'e':
            self.ctrl.e = down
        elif name == 'c' and down:
            self.ctrl.recenter_slice = True
        elif name == 'p' and down:
            self.ctrl.paused = not self.ctrl.paused
        elif name == 'escape' and down:
            self.ctrl.quit = True

    # -------- sim step --------

    def control_to_u(self, st: State):
        """Map key state to (a_world, w_body)."""
        accel_unit = 2.0
        yaw_unit = 1.0
        if self.ctrl.boost:
            accel_unit *= 2.0
            yaw_unit *= 2.0

        # body-frame acceleration command
        ax = (1.0 if self.ctrl.w else 0.0) + (-1.0 if self.ctrl.s else 0.0)
        ay = (1.0 if self.ctrl.d else 0.0) + (-1.0 if self.ctrl.a else 0.0)
        az = (1.0 if self.ctrl.r else 0.0) + (-1.0 if self.ctrl.f else 0.0)
        a_body = jnp.array([ax, ay, az]) * accel_unit

        # convert to world
        Rw = R_from_q(st.q)
        a_world = (Rw @ a_body).astype(jnp.float32)

        # body angular-velocity command (yaw only for now)
        wz = (1.0 if self.ctrl.q else 0.0) + (-1.0 if self.ctrl.e else 0.0)
        w_body = jnp.array([0.0, 0.0, wz * yaw_unit], dtype=jnp.float32)

        # quick brake: zero velocity
        if self.ctrl.brake:
            st = State(st.p, jnp.zeros_like(st.v), st.q, st.w)

        u = jnp.concatenate([a_world, w_body])
        return st, u

    def mapping_update(self, st: State):
        """
        Update the live map from a sparse set of rays.
        """
        p, q = st.p, st.q
        Rw = R_from_q(q)
        rays_w = (self.map_dirs_body @ Rw.T)  # (M,3)
        # Subsample for speed
        idx = jnp.arange(0, rays_w.shape[0], 3)
        sel = rays_w[idx]

        SFS = 24
        ts = jnp.linspace(0.2, 12.0, SFS)

        def per_ray(d):
            t = raycast_depth_gt(p, d)                     # GT sphere tracing (matches training)
            stop_t = jnp.where(jnp.isnan(t), 12.0, t)
            xs = p[None, :] + ts[:, None] * d[None, :]
            m_free = (ts < stop_t).astype(jnp.float32)
            r = ts
            w_seen = m_free / (1.0 + r * r)
            x_hit = p + stop_t * d
            m_hit = jnp.isfinite(t).astype(jnp.float32) * (t <= 12.0)
            return x_hit, m_hit, xs, m_free, w_seen

        hits, m_hits, frees, m_frees, w_seens = jax.vmap(per_ray)(sel)
        ms = update_geom(self.mapstate, hits, m_hits, frees, m_frees)
        ms = update_expo(ms, frees, w_seens)
        self.mapstate = ms

    # -------- renderers --------

    def update_gt_panel(self):
        z = self.slice_z
        xs, ys, Xm, Ym, pts = grid_xy(HASH_CFG.lb, HASH_CFG.ub, self.res, z)
        phi = jax.vmap(phi_gt)(pts).reshape(self.res, self.res)
        phi_np = np.asarray(jax.device_get(phi))
        self.im_gt.set_data(phi_np)
        self.im_gt.set_clim(vmin=phi_np.min(), vmax=phi_np.max())

        # φ=0 contour
        self._clear_contour(self.cont_gt)
        self.cont_gt = self.ax_gt.contour(np.asarray(Xm), np.asarray(Ym), phi_np, levels=[0.0], linewidths=1.5)

        # pose arrow
        p = np.asarray(self.state.p)
        Rw = np.asarray(R_from_q(self.state.q))
        fwd = Rw @ np.array([1.0, 0.0, 0.0])
        self.pose_quiver.set_offsets(np.array([[p[0], p[1]]]))
        self.pose_quiver.set_UVC(np.array([fwd[0]]), np.array([fwd[1]]))

        self.ax_gt.set_xlim(xs[0], xs[-1]); self.ax_gt.set_ylim(ys[0], ys[-1])
        self.ax_gt.set_title(f"GT φ_gt @ z={z:.2f}")

    def update_live_panel(self):
        z = self.slice_z
        xs, ys, Xm, Ym, pts = grid_xy(HASH_CFG.lb, HASH_CFG.ub, self.res, z)

        # Coverage heatmap Qη
        Q = v_Q(pts, self.mapstate.expo.eta).reshape(self.res, self.res)
        Q_np = np.asarray(jax.device_get(Q))
        self.im_live.set_data(Q_np)
        self.im_live.set_clim(0.0, 1.0)
        self.im_live.set_extent([xs[0], xs[-1], ys[0], ys[-1]])

        # Learned φ̂≈0 contour
        phi_hat = v_G(pts, self.mapstate.geom.theta).reshape(self.res, self.res)
        phi_hat_np = np.asarray(jax.device_get(phi_hat))

        self._clear_contour(self.cont_live)
        self.cont_live = self.ax_live.contour(np.asarray(Xm), np.asarray(Ym), phi_hat_np, levels=[0.0], linewidths=1.2)

        self.ax_live.set_xlim(xs[0], xs[-1]); self.ax_live.set_ylim(ys[0], ys[-1])

    def update_cam_panel(self):
        # World-frame rays from body FOV
        Rw = R_from_q(self.state.q)
        rays_w = (self.cam_dirs_body @ Rw.T)  # (M,3)

        # Fast discrete raycast for visualization
        t = fast_raycast_depth_grid(self.state.p, rays_w, S=self.cam_S)  # (M,)
        T = np.asarray(jax.device_get(t)).reshape(self.cam_shape)

        # Map depth to image (NaN -> max)
        tmax = 12.0
        Timg = np.where(np.isfinite(T), T, tmax)
        self.im_cam.set_data(Timg)
        self.im_cam.set_clim(vmin=0.0, vmax=tmax)

    def update_status(self, fps):
        p = np.asarray(self.state.p)
        self.txt.set_text(
            f"pos=({p[0]:+.2f}, {p[1]:+.2f}, {p[2]:+.2f})  "
            f"fps≈{fps:.1f}  "
            f"{'PAUSED' if self.ctrl.paused else ''}"
        )

    # -------- main loop --------

    def update_all(self, bootstrap=False, frame_idx=0):
        t0 = time.time()

        if self.ctrl.recenter_slice:
            self.slice_z = float(self.state.p[2])
            self.ctrl.recenter_slice = False

        # Simulate
        if not self.ctrl.paused:
            st, u = self.control_to_u(self.state)
            self.state = step(st, u, self.cfg)
            # Clamp to avoid going below ground too far (softly)
            zmin = 0.05
            self.state = State(
                p=jnp.where(self.state.p[2] < zmin,
                            self.state.p.at[2].set(zmin),
                            self.state.p),
                v=self.state.v,
                q=self.state.q,
                w=self.state.w
            )
            self.mapping_update(self.state)

        # Render
        self.update_cam_panel()

        # Update GT every frame (cheap)
        self.update_gt_panel()

        # Update live map panel every few frames (heavier)
        if bootstrap or (frame_idx % 5 == 0):
            self.update_live_panel()

        dt = time.time() - t0
        fps = 1.0 / max(dt, 1e-6)
        self.update_status(fps)

        plt.pause(0.001)

    def run(self):
        i = 0
        while not self.ctrl.quit:
            self.update_all(frame_idx=i)
            i += 1


def main():
    app = InteractiveApp()
    app.run()


if __name__ == "__main__":
    main()

```

## live_mvp\src\live_mvp\play_interactive_3d.py

```python
"""
3D interactive viewer for live_mvp with full **process isolation** and **zero UI hitching**.

- Main/UI process: PyVista window (no JAX imported here). Geometry is created ONCE and
  only per-vertex scalars are updated afterwards.
- Child/Sim process: all JAX work (dynamics, GT raycast, live mapping).

Views:
  Left   : Ground-truth shell (|phi_gt| <= eps) + drone pose + HUD.
  Middle : Drone "camera" depth image (triangulated plane textured by t).
  Right  : Live reconstruction point grid with scalar `vis = Q * clamp(1-|phi|/eps,0,1)`.

Controls (chosen to avoid VTK defaults):
  I / K  : forward / back (body-x)
  J / L  : left / right   (body-y)
  U / O  : down / up      (body-z)
  Z / C  : yaw left / right (body-z)
  Shift  : boost
  Space  : brake
  P      : pause physics
  M      : toggle mapping (runs in child process)
  Esc    : quit

Run:
  set PYTHONPATH=%CD%\\src
  python -m live_mvp.play_interactive_3d
"""

from __future__ import annotations

import logging
import time
from dataclasses import dataclass, asdict
from typing import Optional, Tuple

import numpy as np
import pyvista as pv
import multiprocessing as mp
from queue import Empty

# ---------------------------------------------------------------------
# Logging & PyVista noise suppression
# ---------------------------------------------------------------------

log = logging.getLogger("live_mvp.play3d")
if not log.handlers:
    h = logging.StreamHandler()
    h.setFormatter(logging.Formatter("[%(levelname)s] %(asctime)s %(message)s", "%H:%M:%S"))
    log.addHandler(h)
log.setLevel(logging.INFO)

# Quell noisy destructor AttributeErrors on some PyVista builds
try:
    from pyvista.plotting import plotter as _pv_plotter_mod  # type: ignore
    _pv_plotter_mod.BasePlotter.__del__ = lambda self: None  # noqa: E731
except Exception:
    pass

# ---------------------------------------------------------------------
# UI-side math (NumPy only; no JAX imports here)
# ---------------------------------------------------------------------

def quat_to_R_numpy(q: np.ndarray) -> np.ndarray:
    """Return 3x3 rotation matrix from quaternion [w,x,y,z], NumPy only."""
    w, x, y, z = [float(v) for v in q]
    xx, yy, zz = x*x, y*y, z*z
    wx, wy, wz = w*x, w*y, w*z
    xy, xz, yz = x*y, x*z, y*z
    return np.array([
        [1 - 2*(yy+zz), 2*(xy - wz),   2*(xz + wy)],
        [2*(xy + wz),   1 - 2*(xx+zz), 2*(yz - wx)],
        [2*(xz - wy),   2*(yz + wx),   1 - 2*(xx+yy)]
    ], dtype=np.float32)

def make_point_cloud_polydata(pts: np.ndarray) -> pv.PolyData:
    """Create a PolyData with vertex cells; no scalars yet."""
    poly = pv.PolyData()
    pts = np.asarray(pts, dtype=np.float32)
    if pts.ndim != 2 or pts.shape[1] != 3:
        raise ValueError(f"make_point_cloud_polydata expected (N,3), got {pts.shape}")
    n = pts.shape[0]
    poly.points = pts
    verts = np.empty(n*2, dtype=np.int64)
    verts[0::2] = 1
    verts[1::2] = np.arange(n, dtype=np.int64)
    poly.verts = verts
    return poly

def plane_from_image(img2d: np.ndarray, scalars_name: str = "values") -> pv.PolyData:
    """Triangulated plane with point scalars from a 2D image."""
    n_rows, n_cols = img2d.shape
    plane = pv.Plane(center=(0.0, 0.0, 0.0),
                     direction=(0.0, 0.0, 1.0),
                     i_size=float(n_cols),
                     j_size=float(n_rows),
                     i_resolution=max(1, n_cols - 1),
                     j_resolution=max(1, n_rows - 1))
    vals = img2d.astype(np.float32).ravel(order="C")
    if plane.n_points == vals.size:
        plane.point_data[scalars_name] = vals
    else:
        plane.point_data[scalars_name] = np.resize(vals, plane.n_points)
    return plane

# ---------------------------------------------------------------------
# Messages & Controls
# ---------------------------------------------------------------------

@dataclass
class Controls:
    fwd: bool = False; back: bool = False
    left: bool = False; right: bool = False
    down: bool = False; up: bool = False
    yaw_l: bool = False; yaw_r: bool = False
    boost: bool = False
    brake: bool = False
    paused: bool = False
    mapping: bool = False
    quit: bool = False

# UI → Sim:
#   {"type": "ctrl", "ctrl": asdict(Controls)}
#   {"type": "quit"}
#
# Sim → UI:
#   {"type": "init", "gt_points": (Mg,3), "live_pts": (Nl,3), "cam_shape": (h,w), "tmax": float, "lb":(3,), "ub":(3,)}
#   {"type": "state", "p": (3,), "q": (4,), "v": (3,), "w": (3,), "steps": int, "sps": float, "mapping":bool, "paused":bool}
#   {"type": "cam", "img": (h,w) float32}
#   {"type": "live", "vis": (Nl,) float32}   # fixed size, no topology changes!
#   {"type": "log", "msg": str}
#   {"type": "bye"}

# ---------------------------------------------------------------------
# Sim worker process (JAX lives only here)
# ---------------------------------------------------------------------

def _sim_worker(ui2sim: mp.Queue, sim2ui: mp.Queue,
                grid_gt_res=(80,80,40),
                grid_live_res=(48,48,24),
                shell_eps_gt=0.08,
                shell_eps_live=0.12,
                dt=0.05,
                cam_n_az=32, cam_n_el=24, cam_samples=72,
                cam_fov_az=80., cam_fov_el=45.,
                cam_hz=12.0, state_hz=30.0, live_hz=2.0,
                map_update_every_steps=6):
    """Child process target: owns all JAX imports & computation."""

    import jax, jax.numpy as jnp
    from .env_gt import phi_gt, raycast_depth_gt
    from .dyn import State, DynCfg, step, R_from_q
    from .live_map import init_live_map, update_geom, update_expo, MapState, v_Q, v_G, HASH_CFG

    def camera_dirs_body(n_az=32, n_el=24, fov_az_deg=80., fov_el_deg=45.):
        az = jnp.linspace(-jnp.deg2rad(fov_az_deg)/2, jnp.deg2rad(fov_az_deg)/2, n_az)
        el = jnp.linspace(-jnp.deg2rad(fov_el_deg)/2, jnp.deg2rad(fov_el_deg)/2, n_el)
        A, E = jnp.meshgrid(az, el, indexing='xy')
        x = jnp.cos(E) * jnp.cos(A)
        y = jnp.cos(E) * jnp.sin(A)
        z = jnp.sin(E)
        D = jnp.stack([x, y, z], axis=-1)
        D = D / (jnp.linalg.norm(D, axis=-1, keepdims=True) + 1e-9)
        return D.reshape(-1, 3), (int(n_el), int(n_az))

    def fast_raycast_depth_grid(o, D, t0=0.2, t1=12.0, S=72, eps=0.02):
        ts = jnp.linspace(t0, t1, S)
        xs = o[None, None, :] + ts[:, None, None] * D[None, :, :]  # (S,M,3)
        xs_flat = xs.reshape(-1, 3)
        phi = jax.vmap(phi_gt)(xs_flat).reshape(S, -1)
        hit_mask = phi <= eps
        any_hit = hit_mask.any(axis=0)
        first_idx = jnp.argmax(hit_mask, axis=0)
        t = ts[first_idx]
        return jnp.where(any_hit, t, jnp.nan)

    def make_grid(lb: jnp.ndarray, ub: jnp.ndarray, res_xyz: Tuple[int,int,int]):
        nx, ny, nz = res_xyz
        xs = jnp.linspace(lb[0], ub[0], nx)
        ys = jnp.linspace(lb[1], ub[1], ny)
        zs = jnp.linspace(lb[2], ub[2], nz)
        X, Y, Z = jnp.meshgrid(xs, ys, zs, indexing='xy')
        pts = jnp.stack([X, Y, Z], axis=-1).reshape(-1, 3)
        return xs, ys, zs, pts

    def thin_shell_points(pts_jax: jnp.ndarray, phi_fn, shell_eps: float) -> np.ndarray:
        phi = jax.vmap(phi_fn)(pts_jax)
        mask = jnp.abs(phi) <= shell_eps
        pts_np = np.asarray(jax.device_get(pts_jax))
        mask_np = np.asarray(jax.device_get(mask))
        return pts_np[mask_np].astype(np.float32)

    # --- Initialize world, map, state ---
    lb = jnp.asarray(HASH_CFG.lb); ub = jnp.asarray(HASH_CFG.ub)
    _, _, _, pts_gt = make_grid(lb, ub, grid_gt_res)
    _, _, _, pts_live = make_grid(lb, ub, grid_live_res)  # FIXED live grid

    key = jax.random.PRNGKey(0)
    mapstate: MapState = init_live_map(key)
    state = State(p=jnp.array([0., 0., 1.6]),
                  v=jnp.zeros(3),
                  q=jnp.array([1., 0., 0., 0.]),
                  w=jnp.zeros(3))
    cfg = DynCfg(dt=float(dt), drag_v=0.02, drag_w=0.01, a_max=5.0, w_max=2.0)

    cam_dirs, cam_shape = camera_dirs_body(cam_n_az, cam_n_el, cam_fov_az, cam_fov_el)
    tmax = 12.0

    # Build GT shell once and send to UI
    gt_points = thin_shell_points(pts_gt, phi_gt, shell_eps_gt)
    sim2ui.put({"type": "init",
                "gt_points": np.asarray(jax.device_get(gt_points), dtype=np.float32),
                "live_pts":  np.asarray(jax.device_get(pts_live), dtype=np.float32),  # fixed topology
                "cam_shape": cam_shape,
                "tmax": float(tmax),
                "lb": np.asarray(jax.device_get(lb), dtype=np.float32),
                "ub": np.asarray(jax.device_get(ub), dtype=np.float32)})

    # Warm-up compile
    _ = step(state, jnp.zeros(6), cfg)
    _ = fast_raycast_depth_grid(state.p, cam_dirs, S=cam_samples)

    # Timers
    next_sim_t = time.perf_counter()
    last_cam_t = 0.0
    last_state_t = 0.0
    last_live_t = 0.0
    cam_dt = 1.0/max(1e-6, cam_hz)
    state_dt = 1.0/max(1e-6, state_hz)
    live_dt = 1.0/max(1e-6, live_hz)

    steps = 0
    rate_win_t0 = time.time()
    rate_win_steps0 = 0
    steps_per_sec = 0.0

    ctrl = Controls()
    quit_flag = False

    def control_to_u(st: State, ctrl: Controls):
        accel_unit = 3.0
        yaw_unit = 1.2
        if ctrl.boost:
            accel_unit *= 2.0
            yaw_unit *= 2.0
        ax = (1.0 if ctrl.fwd else 0.0) + (-1.0 if ctrl.back else 0.0)
        ay = (1.0 if ctrl.right else 0.0) + (-1.0 if ctrl.left else 0.0)
        az = (1.0 if ctrl.up else 0.0) + (-1.0 if ctrl.down else 0.0)
        a_body = jnp.array([ax, ay, az]) * accel_unit
        Rw = R_from_q(st.q)
        a_world = Rw @ a_body
        wz = (-1.0 if ctrl.yaw_l else 0.0) + (1.0 if ctrl.yaw_r else 0.0)
        w_body = jnp.array([0.0, 0.0, wz * yaw_unit])
        if ctrl.brake:
            st = State(st.p, jnp.zeros_like(st.v), st.q, st.w)
        return st, jnp.concatenate([a_world, w_body])

    def mapping_update_once(mapstate: MapState, st: State) -> MapState:
        p, q = st.p, st.q
        Rw = R_from_q(q)
        dirs_body, _ = camera_dirs_body(n_az=16, n_el=2, fov_az_deg=100., fov_el_deg=40.)
        rays_w = (dirs_body @ Rw.T)
        idx = jnp.arange(0, rays_w.shape[0], 2)
        sel = rays_w[idx]
        SFS = 16
        ts = jnp.linspace(0.2, 12.0, SFS)

        def per_ray(d):
            t = raycast_depth_gt(p, d)
            stop_t = jnp.where(jnp.isnan(t), 12.0, t)
            xs = p[None,:] + ts[:,None]*d[None,:]
            m_free = (ts < stop_t).astype(jnp.float32)
            w_seen = m_free / (1.0 + ts*ts)
            x_hit = p + stop_t * d
            m_hit = jnp.isfinite(t).astype(jnp.float32) * (t <= 12.0)
            return x_hit, m_hit, xs, m_free, w_seen

        hits, m_hits, frees, m_frees, w_seens = jax.vmap(per_ray)(sel)
        new_map = update_geom(mapstate, hits, m_hits, frees, m_frees)
        new_map = update_expo(new_map, frees, w_seens)
        return new_map

    def compute_live_vis(ms: MapState) -> np.ndarray:
        """Return vis (N,) for the FIXED live grid."""
        G = v_G(pts_live, ms.geom.theta)  # (N,)
        Q = v_Q(pts_live, ms.expo.eta)    # (N,)
        mask = 1.0 - jnp.clip(jnp.abs(G) / shell_eps_live, 0.0, 1.0)  # in [0,1]
        vis = (Q * mask).astype(jnp.float32)
        return np.asarray(jax.device_get(vis))

    try:
        while not quit_flag:
            # Drain UI messages (non-blocking)
            drained = 0
            while True:
                try:
                    m = ui2sim.get_nowait()
                except Empty:
                    break
                drained += 1
                tp = m.get("type")
                if tp == "quit":
                    quit_flag = True
                    break
                if tp == "ctrl":
                    ctrl = Controls(**{**asdict(ctrl), **m.get("ctrl", {})})

            # Fixed-step sim
            now = time.perf_counter()
            if now >= next_sim_t:
                if not ctrl.paused:
                    st_u, u = control_to_u(state, ctrl)
                    state = step(st_u, u, cfg)
                    if float(state.p[2]) < 0.05:
                        state = State(state.p.at[2].set(0.05), state.v, state.q, state.w)
                    steps += 1
                    if ctrl.mapping and (steps % int(max(1, map_update_every_steps)) == 0):
                        mapstate = mapping_update_once(mapstate, state)
                next_sim_t += dt

                # steps/s
                now_s = time.time()
                if now_s - rate_win_t0 >= 1.0:
                    steps_per_sec = (steps - rate_win_steps0) / (now_s - rate_win_t0)
                    rate_win_steps0 = steps
                    rate_win_t0 = now_s

            # State telemetry
            if time.time() - last_state_t >= state_dt:
                sim2ui.put({"type": "state",
                            "p": np.asarray(state.p, np.float32),
                            "q": np.asarray(state.q, np.float32),
                            "v": np.asarray(state.v, np.float32),
                            "w": np.asarray(state.w, np.float32),
                            "steps": int(steps),
                            "sps": float(steps_per_sec),
                            "mapping": bool(ctrl.mapping),
                            "paused": bool(ctrl.paused)})
                last_state_t = time.time()

            # Camera telemetry
            if time.time() - last_cam_t >= cam_dt:
                Rw = R_from_q(state.q)
                rays_w = (cam_dirs @ Rw.T)
                t = fast_raycast_depth_grid(state.p, rays_w, S=cam_samples)
                img = np.asarray(jax.device_get(t)).reshape(cam_shape)
                img = np.where(np.isfinite(img), tmax, img).astype(np.float32)  # far= tmax
                sim2ui.put({"type": "cam", "img": img})
                last_cam_t = time.time()

            # Live vis telemetry (fixed size array)
            if ctrl.mapping and (time.time() - last_live_t >= live_dt):
                vis = compute_live_vis(mapstate)  # (N,)
                sim2ui.put({"type": "live", "vis": vis})
                last_live_t = time.time()

            time.sleep(0.001)  # be nice to the scheduler

    except Exception as e:
        sim2ui.put({"type": "log", "msg": f"[sim-exception] {e!r}"} )
    finally:
        sim2ui.put({"type": "bye"})


# ---------------------------------------------------------------------
# UI application (main process)
# ---------------------------------------------------------------------

class Interactive3DApp:
    def __init__(self):
        # IPC queues
        self.ui2sim: mp.Queue = mp.Queue(maxsize=8)
        self.sim2ui: mp.Queue = mp.Queue(maxsize=8)

        # Start sim process
        self.proc = mp.Process(target=_sim_worker, args=(self.ui2sim, self.sim2ui), daemon=True)
        self.proc.start()
        log.info("Sim process started.")

        # Placeholders filled by 'init'
        self.lb = np.array([-6.0, -6.0, 0.0], np.float32)
        self.ub = np.array([+6.0, +6.0, 4.0], np.float32)
        self.cam_shape = (24, 32)
        self.tmax = 12.0
        self.gt_points = np.zeros((0,3), np.float32)
        self.live_pts = np.zeros((0,3), np.float32)

        # Dynamic data
        self.p = np.array([0.,0.,1.6], np.float32)
        self.q = np.array([1.,0.,0.,0.], np.float32)
        self.v = np.zeros(3, np.float32)
        self.w = np.zeros(3, np.float32)
        self.sps = 0.0; self.steps = 0
        self.mapping = False; self.paused = False

        # Controls
        self.ctrl = Controls()

        # PyVista window
        pv.set_plot_theme("document")
        try:
            self.pl = pv.Plotter(shape=(1,3), window_size=(1500, 520), enable_keybindings=False)
        except TypeError:
            self.pl = pv.Plotter(shape=(1,3), window_size=(1500, 520))
            for attr in ("enable_keybindings", "enable_key_bindings"):
                if hasattr(self.pl, attr):
                    try: setattr(self.pl, attr, False)
                    except Exception: pass
        self.pl.add_text("live_mvp  3D interactive (decoupled UI)", font_size=10)

        # Left: GT + pose + HUD (actors created once)
        self.pl.subplot(0,0)
        self.gt_poly: Optional[pv.PolyData] = None
        self.gt_actor = None
        self.drone_actor = None  # we'll reconstruct small meshes each frame (cheap)
        self.hud_actor = None
        self.pl.show_axes()

        # Middle: Camera plane (mesh created once, we only update scalars)
        self.pl.subplot(0,1)
        img0 = np.zeros(self.cam_shape, np.float32)
        self.cam_mesh = plane_from_image(img0, "values")
        self.cam_actor = self.pl.add_mesh(self.cam_mesh, scalars="values",
                                          cmap="viridis", clim=[0.0, float(self.tmax)],
                                          show_scalar_bar=False, lighting=False)
        self.pl.show_axes()

        # Right: Live cloud (fixed point set created once; we only update scalars "vis")
        self.pl.subplot(0,2)
        self.live_poly: Optional[pv.PolyData] = None
        self.live_actor = None
        self.pl.show_axes()

        # Key bindings
        self._bind_keys()

        # Wait for 'init' to arrive (up to 5s)
        t0 = time.time()
        while time.time() - t0 < 5.0:
            if self._drain_once():
                if self.gt_points.size and self.live_pts.size:
                    self._build_static_actors()
                    break
            time.sleep(0.01)

    # ------------------ Messaging ------------------

    def _send_ctrl(self):
        try:
            self.ui2sim.put_nowait({"type": "ctrl", "ctrl": asdict(self.ctrl)})
        except Exception:
            pass

    def _drain_once(self) -> bool:
        got = False
        for _ in range(8):
            try:
                m = self.sim2ui.get_nowait()
            except Empty:
                break
            got = True
            tp = m.get("type")
            if tp == "init":
                self.gt_points = np.asarray(m["gt_points"], np.float32)
                self.live_pts = np.asarray(m["live_pts"], np.float32)
                self.cam_shape = tuple(m["cam_shape"])
                self.tmax = float(m.get("tmax", 12.0))
                self.lb = np.asarray(m.get("lb", self.lb), np.float32)
                self.ub = np.asarray(m.get("ub", self.ub), np.float32)
            elif tp == "state":
                self.p = np.asarray(m["p"], np.float32)
                self.q = np.asarray(m["q"], np.float32)
                self.v = np.asarray(m["v"], np.float32)
                self.w = np.asarray(m["w"], np.float32)
                self.steps = int(m.get("steps", self.steps))
                self.sps = float(m.get("sps", self.sps))
                self.mapping = bool(m.get("mapping", self.mapping))
                self.paused = bool(m.get("paused", self.paused))
            elif tp == "cam":
                img = np.asarray(m["img"], np.float32)
                self._update_cam_scalars(img)
            elif tp == "live":
                vis = np.asarray(m["vis"], np.float32)
                self._update_live_scalars(vis)
            elif tp == "log":
                log.info(m.get("msg",""))
            elif tp == "bye":
                pass
        return got

    # ------------------ Actor construction & updates ------------------

    def _build_static_actors(self):
        # Left: GT shell (static)
        self.pl.subplot(0,0)
        try:
            if self.gt_actor is not None:
                self.pl.remove_actor(self.gt_actor)
        except Exception:
            pass
        self.gt_poly = make_point_cloud_polydata(self.gt_points)
        self.gt_actor = self.pl.add_mesh(self.gt_poly, color="lightgray",
                                         render_points_as_spheres=True, point_size=5.0)

        # Right: Live cloud (fixed points, attach 'vis' once)
        self.pl.subplot(0,2)
        try:
            if self.live_actor is not None:
                self.pl.remove_actor(self.live_actor)
        except Exception:
            pass
        self.live_poly = make_point_cloud_polydata(self.live_pts)
        # initialize vis to zeros
        self.live_poly.point_data["vis"] = np.zeros((self.live_pts.shape[0],), dtype=np.float32)
        # cheaper rendering without spheres
        self.live_actor = self.pl.add_mesh(self.live_poly, scalars="vis",
                                           render_points_as_spheres=False, point_size=3.0,
                                           clim=[0.0, 1.0], cmap="viridis",
                                           nan_color=None)

    def _update_cam_scalars(self, img: np.ndarray):
        """Update the existing plane's point scalars in-place (no actor churn)."""
        vals = img.astype(np.float32).ravel(order="C")
        pd = self.cam_mesh.point_data
        if "values" in pd and pd["values"].size == vals.size:
            pd["values"][:] = vals
        else:
            pd["values"] = vals
        # VTK will detect modified arrays automatically on render

    def _update_live_scalars(self, vis: np.ndarray):
        """Update 'vis' on the fixed live point cloud (no actor churn)."""
        if self.live_poly is None:
            return
        pd = self.live_poly.point_data
        n = self.live_poly.n_points
        if vis.size != n:
            # safety: resize (shouldn't happen)
            vis = np.resize(vis.astype(np.float32), n)
        if "vis" in pd and pd["vis"].size == n:
            pd["vis"][:] = vis
        else:
            pd["vis"] = vis

    def _update_pose_and_hud(self):
        # Recreate small pose meshes (cheap) — could be actor transforms too
        self.pl.subplot(0,0)
        p = self.p.astype(np.float32)
        Rw = quat_to_R_numpy(self.q)
        fwd = (Rw @ np.array([1.0, 0.0, 0.0], np.float32))
        sphere = pv.Sphere(radius=0.08, center=p)
        arrow = pv.Arrow(start=p, direction=fwd, tip_length=0.2, tip_radius=0.05,
                         shaft_radius=0.02, scale=0.4)
        try:
            if self.drone_actor is not None:
                self.pl.remove_actor(self.drone_actor)
        except Exception:
            pass
        self.drone_actor = self.pl.add_mesh(sphere, color="orange")
        _ = self.pl.add_mesh(arrow, color="red")  # separate actor; not stored

        # HUD
        try:
            if self.hud_actor is not None:
                self.pl.remove_actor(self.hud_actor)
        except Exception:
            pass
        spd = float(np.linalg.norm(self.v))
        yaw_rate = float(self.w[2])
        def on(b): return "●" if b else "○"
        keys_line = (
            f"I{on(self.ctrl.fwd)} K{on(self.ctrl.back)}  "
            f"J{on(self.ctrl.left)} L{on(self.ctrl.right)}  "
            f"U{on(self.ctrl.down)} O{on(self.ctrl.up)}  "
            f"Z{on(self.ctrl.yaw_l)} C{on(self.ctrl.yaw_r)}  "
            f"Shift{on(self.ctrl.boost)} Space{on(self.ctrl.brake)}  "
            f"P{on(self.ctrl.paused)} M{on(self.ctrl.mapping)}"
        )
        hud = (
            f"[steps={self.steps} ~{self.sps:.1f} sps]  "
            f"p=({p[0]:+.2f},{p[1]:+.2f},{p[2]:+.2f})  "
            f"|v|={spd:.2f}  yaw={yaw_rate:.2f}"
            f"\nKeys: {keys_line}"
        )
        self.hud_actor = self.pl.add_text(hud, font_size=10, color="white")

    # ------------------ Input handling ------------------

    def _bind_keys(self):
        iren = getattr(self.pl, "iren", None)
        if iren is not None:
            if hasattr(iren, "add_observer"):
                iren.add_observer("KeyPressEvent", self._on_vtk_key_press)
                iren.add_observer("KeyReleaseEvent", self._on_vtk_key_release)
            elif hasattr(iren, "AddObserver"):
                iren.AddObserver("KeyPressEvent", self._on_vtk_key_press)
                iren.AddObserver("KeyReleaseEvent", self._on_vtk_key_release)
        if hasattr(self.pl, "add_key_event"):
            for k in ("i","k","j","l","u","o","z","c","space","p","escape","Esc","Shift_L","Shift_R","m"):
                self.pl.add_key_event(k, lambda k=k: self._apply_press(self._norm(k)))

    def _norm(self, token: str) -> str:
        t = token.lower()
        if t in ("escape","esc"): return "escape"
        if t in ("shift_l","shift_r","shift"): return "shift"
        if t == "space": return "space"
        return t

    def _on_vtk_key_press(self, obj, evt):
        try: token = obj.GetKeySym()
        except Exception: token = ""
        self._apply_press(self._norm(str(token)))

    def _on_vtk_key_release(self, obj, evt):
        try: token = obj.GetKeySym()
        except Exception: token = ""
        self._apply_release(self._norm(str(token)))

    def _apply_press(self, key: str):
        if key == "escape":
            self.ctrl.quit = True
            try: self.ui2sim.put_nowait({"type": "quit"})
            except Exception: pass
            try: self.pl.close()
            except Exception: pass
            return
        if key == "p":
            self.ctrl.paused = not self.ctrl.paused; self._send_ctrl(); return
        if key == "m":
            # toggle mapping on release to avoid double fire
            return
        if key == "shift": self.ctrl.boost = True;  self._send_ctrl(); return
        if key == "space": self.ctrl.brake = True;  self._send_ctrl(); return
        if   key == "i": self.ctrl.fwd   = True
        elif key == "k": self.ctrl.back  = True
        elif key == "j": self.ctrl.left  = True
        elif key == "l": self.ctrl.right = True
        elif key == "u": self.ctrl.down  = True
        elif key == "o": self.ctrl.up    = True
        elif key == "z": self.ctrl.yaw_l = True
        elif key == "c": self.ctrl.yaw_r = True
        self._send_ctrl()

    def _apply_release(self, key: str):
        if key == "shift": self.ctrl.boost = False; self._send_ctrl(); return
        if key == "space": self.ctrl.brake = False; self._send_ctrl(); return
        if key == "m":
            self.ctrl.mapping = not self.ctrl.mapping; self._send_ctrl(); return
        if   key == "i": self.ctrl.fwd   = False
        elif key == "k": self.ctrl.back  = False
        elif key == "j": self.ctrl.left  = False
        elif key == "l": self.ctrl.right = False
        elif key == "u": self.ctrl.down  = False
        elif key == "o": self.ctrl.up    = False
        elif key == "z": self.ctrl.yaw_l = False
        elif key == "c": self.ctrl.yaw_r = False
        self._send_ctrl()

    # ------------------ Main UI loop ------------------

    def run(self):
        try:
            self.pl.show(auto_close=False, interactive_update=True)
        except TypeError:
            try: self.pl.show(auto_close=False)
            except TypeError: self.pl.show()

        try:
            while not self.ctrl.quit:
                self._drain_once()
                self._update_pose_and_hud()
                try: self.pl.update()
                except Exception: pass
                # keep sim sync'd with latest control state
                self._send_ctrl()
                time.sleep(1.0/30.0)  # steady 30 FPS UI
        except KeyboardInterrupt:
            pass
        finally:
            try:
                self.ctrl.quit = True
                self.ui2sim.put_nowait({"type":"quit"})
            except Exception:
                pass
            try:
                if self.proc.is_alive():
                    self.proc.join(timeout=1.0)
            except Exception:
                pass
            try: self.pl.close()
            except Exception: pass

# ---------------------------------------------------------------------
# Entrypoint
# ---------------------------------------------------------------------

def main():
    try:
        mp.set_start_method("spawn")
    except RuntimeError:
        pass
    app = Interactive3DApp()
    app.run()

if __name__ == "__main__":
    main()

```

## live_mvp\src\live_mvp\policy.py

```python

import jax, jax.numpy as jnp
from typing import NamedTuple
from .live_map import G_phi, Q_expo
from .dyn import R_from_q, body_rays_world
from .render import sdf_to_sigma, RenderCfg

# --------
# Utility MLP for the policy
# --------
def init_mlp(key, sizes):
    keys = jax.random.split(key, len(sizes)-1)
    params=[]; prev=sizes[0]
    for k, n in zip(keys, sizes[1:]):
        W = jax.random.normal(k, (prev, n)) * (1.0/jnp.sqrt(prev))
        b = jnp.zeros((n,)); params.append((W,b)); prev=n
    return tuple(params)

def mlp_apply(params, x):
    for W,b in params[:-1]: 
        x = jax.nn.tanh(x @ W + b)
    W,b = params[-1]; 
    return x @ W + b

# --------
# (A) Non-learned 3D Anchor-Lattice features
# --------
def anchor_grid_body(K=12, R=3.0, H=5, z_min=-1.0, z_max=1.0, include_center=True):
    """Body-frame anchor offsets: K points on a ring at radius R,
    replicated at H evenly spaced z-levels in [z_min, z_max], plus optional center."""
    az = jnp.linspace(0.0, 2*jnp.pi, K, endpoint=False)
    ring = jnp.stack([R*jnp.cos(az), R*jnp.sin(az), jnp.zeros_like(az)], axis=-1)  # (K,3)
    zs = jnp.linspace(z_min, z_max, H)
    def add_z(z): return ring + jnp.array([0.0, 0.0, z])
    anchors = jax.vmap(add_z)(zs).reshape(-1, 3)  # (H*K,3)
    if include_center:
        anchors = jnp.concatenate([anchors, jnp.array([[0.0, 0.0, 0.0]])], axis=0)
    return anchors  # (N,3)

ANCHORS_BODY = anchor_grid_body(K=12, R=3.0, H=5, z_min=-1.0, z_max=1.0, include_center=True)
ANCHOR_FEAT_DIM = ANCHORS_BODY.shape[0] * 2  # channels: [phi_clip, exposure]

def anchor_features(p, q, theta, eta):
    """Non-learned 3D features: for each anchor point around the drone, return:
      - clipped & normalized SDF ([-1,1])
      - exposure Q in [0,1]
    Output shape: (ANCHOR_FEAT_DIM,)"""
    Rw = R_from_q(q)
    anchors_world = (ANCHORS_BODY @ Rw.T) + p  # (N,3)
    phi = jax.vmap(G_phi, in_axes=(0,None))(anchors_world, theta)   # (N,)
    E   = jax.vmap(Q_expo, in_axes=(0,None))(anchors_world, eta)    # (N,)
    phi_clip = jnp.clip(phi, -0.5, 0.5) / 0.5  # [-1,1] for stability
    return jnp.stack([phi_clip, E], axis=1).reshape(-1)             # (2N,)

# --------
# (B) Non-learned "Unseen Compass"
# --------
def compass_rays_body(n_az=24, n_el=3, fov_az_deg=360., el_min_deg=-25., el_max_deg=25.):
    az = jnp.linspace(-jnp.deg2rad(fov_az_deg)/2, jnp.deg2rad(fov_az_deg)/2, n_az, endpoint=False)
    el = jnp.deg2rad(jnp.linspace(el_min_deg, el_max_deg, n_el))
    A,E = jnp.meshgrid(az, el, indexing='xy')
    x = jnp.cos(E)*jnp.cos(A); y = jnp.cos(E)*jnp.sin(A); z = jnp.sin(E)
    D = jnp.stack([x,y,z], axis=-1)
    D = D/(jnp.linalg.norm(D, axis=-1, keepdims=True)+1e-9)
    return D.reshape(-1,3)  # (M,3)

COMPASS_BODY = compass_rays_body(n_az=24, n_el=3)
COMPASS_M = COMPASS_BODY.shape[0]

def unseen_potential_ray(o, d, theta, eta, rcfg: RenderCfg, S=32):
    """Non-learned info-gain-ish integral along ray using live map only."""
    ts = jnp.linspace(rcfg.t0, rcfg.t1, S)
    dt = (rcfg.t1 - rcfg.t0) / (S - 1 + 1e-9)
    xs = o[None,:] + ts[:,None]*d[None,:]                  # (S,3)

    phi   = jax.vmap(G_phi, in_axes=(0,None))(xs, theta)   # (S,)
    sigma = sdf_to_sigma(phi, rcfg.eps_shell)              # shell around surfaces
    alpha = 1.0 - jnp.exp(-sigma * dt)                     # absorption
    T     = jnp.cumprod(jnp.concatenate([jnp.ones((1,)), 1.0 - alpha[:-1]]))
    E     = jax.vmap(Q_expo, in_axes=(0,None))(xs, eta)    # exposure in [0,1]
    unseen = 1.0 - jax.lax.stop_gradient(E)                # don't backprop into map
    w_dist = 1.0 / (1.0 + ts*ts)                           # prefer nearer opportunities
    w = T * alpha * unseen * w_dist
    return w.sum()                                         # scalar potential per ray

def unseen_compass_features(p, q, theta, eta, rcfg: RenderCfg):
    """Returns per-direction potentials (M,) and a 3D direction summary (vec)."""
    rays_w = body_rays_world(q, COMPASS_BODY)              # (M,3)
    o = p
    pot = jax.vmap(lambda d: unseen_potential_ray(o, d, theta, eta, rcfg))(rays_w)  # (M,)
    vec = (pot[:,None] * rays_w).sum(0) / (pot.sum() + 1e-9)                         # (3,)
    return pot, vec  # (M,), (3,)

```

## live_mvp\src\live_mvp\render.py

```python

from typing import NamedTuple
import jax, jax.numpy as jnp
from .live_map import G_phi, Q_expo

class RenderCfg(NamedTuple):
    t0: float = 0.2
    t1: float = 12.0
    S:  int   = 64      # samples per ray
    eps_shell: float = 0.18
    r0: float = 2.5
    tau_r: float = 0.8
    theta_min_deg: float = 20.0
    theta_max_deg: float = 60.0
    tau_theta: float = 0.08
    unseen_gamma: float = 1.3

def sdf_to_sigma(phi, eps): 
    return jax.nn.softplus(-phi/eps)

def expected_hit_live(o, d, theta, rcfg: RenderCfg):
    ts = jnp.linspace(rcfg.t0, rcfg.t1, rcfg.S)
    dt = (rcfg.t1-rcfg.t0)/(rcfg.S-1+1e-9)
    xs = o[None,:] + ts[:,None]*d[None,:]
    phi = jax.vmap(G_phi, in_axes=(0,None))(xs, theta)
    sigma = sdf_to_sigma(phi, rcfg.eps_shell)
    alpha = 1.0 - jnp.exp(-sigma*dt)
    T = jnp.cumprod(jnp.concatenate([jnp.ones((1,)), 1.0-alpha[:-1]]))
    w = (T*alpha); w = w/(w.sum()+1e-9)
    xh = (w[:,None]*xs).sum(0)
    seen = (T*alpha).sum()
    return xh, seen, xs, T, alpha

def incidence_weight(cos_inc, rcfg):
    cmin = jnp.cos(jnp.deg2rad(rcfg.theta_max_deg))
    cmax = jnp.cos(jnp.deg2rad(rcfg.theta_min_deg))
    w_lo = jax.nn.sigmoid((cos_inc - cmin)/(rcfg.tau_theta+1e-9))
    w_hi = jax.nn.sigmoid((cmax - cos_inc)/(rcfg.tau_theta+1e-9))
    return w_lo * w_hi

def close_weight(r, rcfg): 
    return jax.nn.sigmoid((rcfg.r0 - r)/(rcfg.tau_r+1e-9))

def recon_reward_for_ray(o, d, theta, eta, rcfg: RenderCfg):
    d = d/(jnp.linalg.norm(d)+1e-9)
    xh, seen, xs, T, alpha = expected_hit_live(o, d, theta, rcfg)
    # normals from live SDF
    n = jax.grad(G_phi)(xh, theta); n = n/(jnp.linalg.norm(n)+1e-9)
    v = -d
    cos_inc = jnp.abs(jnp.dot(n, v))
    dist = jnp.linalg.norm(xh - o)
    w_inc = incidence_weight(cos_inc, rcfg)
    w_close = close_weight(dist, rcfg)
    # unseen from live exposure
    E = Q_expo(xh, eta)
    w_unseen = (1.0 - jax.lax.stop_gradient(E)) ** rcfg.unseen_gamma
    return seen * w_inc * w_close * w_unseen

```

## live_mvp\src\live_mvp\train_live.py

```python
from functools import partial
from typing import NamedTuple
import jax, jax.numpy as jnp, optax

from .env_gt import raycast_depth_gt
from .live_map import init_live_map, update_geom, update_expo, MapState
from .render import RenderCfg, recon_reward_for_ray
from .dyn import State, DynCfg, step, body_rays_world, R_from_q
from .policy import init_mlp, mlp_apply, anchor_features, ANCHOR_FEAT_DIM
from .policy import unseen_compass_features, COMPASS_M


def ray_dirs_body(n_az=12, n_el=3, fov_az=100., fov_el=40.):
    az = jnp.linspace(-jnp.deg2rad(fov_az)/2, jnp.deg2rad(fov_az)/2, n_az)
    el = jnp.linspace(-jnp.deg2rad(fov_el)/2, jnp.deg2rad(fov_el)/2, n_el)
    A, E = jnp.meshgrid(az, el, indexing='xy')
    x = jnp.cos(E) * jnp.cos(A); y = jnp.cos(E) * jnp.sin(A); z = jnp.sin(E)
    D = jnp.stack([x, y, z], axis=-1)
    D = D / (jnp.linalg.norm(D, axis=-1, keepdims=True) + 1e-9)
    return D.reshape(-1, 3)


RAYS_BODY = ray_dirs_body()


class SimCfg(NamedTuple):
    steps: int = 80
    rcfg: RenderCfg = RenderCfg()
    dyn: DynCfg = DynCfg()
    w_coll: float = 4.0
    margin: float = 0.12
    w_ctrl: float = 0.01


def soft_collision_live(p, theta, margin):
    from .live_map import G_phi
    return jax.nn.softplus(margin - G_phi(p, theta))


def _rollout_loss_impl(policy_params, mapstate: MapState, states0, key, sim: SimCfg):
    """One environment, N drones, train policy; update map online each step."""
    N = states0.p.shape[0]

    def one_step(carry, _):
        key, states, mapstate = carry

        # === 1) Online mapping: simulate depth on GT, update live map ===
        def update_from_drone(i, ms):
            p = states.p[i]; q = states.q[i]
            rays_w = body_rays_world(q, RAYS_BODY)
            idx = jnp.arange(0, RAYS_BODY.shape[0], 4)           # subsample for speed
            sel = rays_w[idx]

            # Fixed sample positions along each ray; mask beyond measured depth
            SFS = 24
            ts = jnp.linspace(sim.rcfg.t0, sim.rcfg.t1, SFS)     # (SFS,)

            def per_ray(d):
                t = raycast_depth_gt(p, d)                        # full-scene GT depth
                stop_t = jnp.where(jnp.isnan(t), sim.rcfg.t1, t)
                xs = p[None, :] + ts[:, None] * d[None, :]       # (SFS,3)
                # free-space mask: everything strictly before stop_t
                m_free = (ts < stop_t).astype(jnp.float32)       # (SFS,)
                # exposure weights ~ 1/r^2 (softened)
                r = ts
                w_seen = m_free / (1.0 + r * r)
                # hit point & mask
                x_hit = p + stop_t * d
                m_hit = jnp.isfinite(t).astype(jnp.float32) * (t <= sim.rcfg.t1)
                return x_hit, m_hit, xs, m_free, w_seen

            hits, m_hits, frees, m_frees, w_seens = jax.vmap(per_ray)(sel)
            # Update geometry (masked)
            ms = update_geom(ms, hits, m_hits, frees, m_frees)
            # Update exposure (weighted)
            ms = update_expo(ms, frees, w_seens)
            return ms

        mapstate = jax.lax.fori_loop(0, N, update_from_drone, mapstate)

        # === 2) Policy obs: non-learned anchor-lattice + unseen compass + kinematics ===
        Rws = jax.vmap(R_from_q)(states.q)
        fwd = jnp.einsum('nij,j->ni', Rws, jnp.array([1., 0., 0.]))
        def embed_one(i):
            anch = anchor_features(states.p[i], states.q[i], mapstate.geom.theta, mapstate.expo.eta)
            pot, vec = unseen_compass_features(states.p[i], states.q[i],
                                               mapstate.geom.theta, mapstate.expo.eta, sim.rcfg)
            obs = jnp.concatenate([states.p[i], states.v[i], fwd[i], anch, pot, vec])
            return obs
        obs = jax.vmap(embed_one)(jnp.arange(N))
        u_raw = jax.vmap(lambda o: mlp_apply(policy_params, o))(obs)

        # === 3) Dynamics ===
        states_next = State(
            p=jax.vmap(lambda st, u: step(st, u, sim.dyn).p)(states, u_raw),
            v=jax.vmap(lambda st, u: step(st, u, sim.dyn).v)(states, u_raw),
            q=jax.vmap(lambda st, u: step(st, u, sim.dyn).q)(states, u_raw),
            w=jax.vmap(lambda st, u: step(st, u, sim.dyn).w)(states, u_raw),
        )

        # === 4) Reward from LIVE map only ===
        def drone_reward(i):
            o = states_next.p[i]; q = states_next.q[i]
            rays_w = body_rays_world(q, RAYS_BODY)
            idx = jnp.arange(0, RAYS_BODY.shape[0], 4)
            sel = rays_w[idx]
            rws = jax.vmap(lambda d: recon_reward_for_ray(o, d, mapstate.geom.theta, mapstate.expo.eta, sim.rcfg))(sel)
            return rws.mean()
        recon_rew = jax.vmap(drone_reward)(jnp.arange(N))

        # penalties
        coll = jax.vmap(lambda p: soft_collision_live(p, mapstate.geom.theta, sim.margin))(states_next.p)
        ctrl = (u_raw ** 2).sum(axis=1)

        # --- sanitize numerics (avoid NaNs/Infs propagating) ---
        recon_rew = jnp.nan_to_num(recon_rew, nan=0.0, posinf=0.0, neginf=0.0)
        coll = jnp.nan_to_num(coll, nan=0.0, posinf=0.0, neginf=0.0)
        ctrl = jnp.nan_to_num(ctrl, nan=0.0, posinf=0.0, neginf=0.0)

        loss = (sim.w_coll * coll + sim.w_ctrl * ctrl).mean() - recon_rew.mean()
        loss = jnp.nan_to_num(loss, nan=0.0, posinf=0.0, neginf=0.0)

        metrics = dict(
            recon=jnp.nan_to_num(recon_rew.mean(), nan=0.0, posinf=0.0, neginf=0.0),
            coll=jnp.nan_to_num(coll.mean(),      nan=0.0, posinf=0.0, neginf=0.0),
            ctrl=jnp.nan_to_num(ctrl.mean(),      nan=0.0, posinf=0.0, neginf=0.0),
        )
        return (key, states_next, mapstate), (loss, metrics)

    (carry_f, outs) = jax.lax.scan(one_step, (key, states0, mapstate), None, length=sim.steps)
    losses, metrics_seq = outs
    loss = jnp.nan_to_num(losses.mean(), nan=0.0, posinf=0.0, neginf=0.0)
    # metrics_seq is a pytree dict of arrays with leading time dimension
    metrics = {k: jnp.nan_to_num(v.mean(), nan=0.0, posinf=0.0, neginf=0.0) for k, v in metrics_seq.items()}
    return loss, metrics, carry_f[2]  # updated mapstate


# -------------
# JIT-fused training step (GPU-resident)
# -------------
POLICY_OPT = optax.adam(3e-3)


def _train_step_impl(policy_params, opt_state, mapstate, states0, key, sim: SimCfg):
    def _loss_with_aux(pp):
        loss, metrics, mapstate_out = _rollout_loss_impl(pp, mapstate, states0, key, sim)
        return loss, (metrics, mapstate_out)

    (loss, (metrics, mapstate_new)), grads = jax.value_and_grad(_loss_with_aux, has_aux=True)(policy_params)
    # sanitize grads (rarely needed, but safe)
    grads = jax.tree.map(lambda g: jnp.nan_to_num(g, nan=0.0, posinf=0.0, neginf=0.0), grads)

    updates, opt_state = POLICY_OPT.update(grads, opt_state, policy_params)
    policy_params = optax.apply_updates(policy_params, updates)
    return policy_params, opt_state, mapstate_new, loss, metrics


# JIT-compiled variant (used when it helps)
@partial(jax.jit, static_argnames=("sim",), donate_argnums=(0, 1, 2))
def _train_step_jit(policy_params, opt_state, mapstate, states0, key, sim: SimCfg):
    return _train_step_impl(policy_params, opt_state, mapstate, states0, key, sim)


def _pick_first_device():
    # Prefer CUDA/ROCm if present; otherwise fall back to CPU.
    for backend in ("cuda", "rocm"):
        try:
            devs = jax.devices(backend)
            if devs:
                return devs[0]
        except RuntimeError:
            pass
    return jax.devices()[0]


def train_step(policy_params, opt_state, mapstate, states0, key, sim: SimCfg):
    """
    Wrapper that runs JIT on GPU or larger runs, and plain eager on tiny CPU runs.
    This makes the smoke test fast and robust on CPU-only machines.
    """
    backend = jax.default_backend()
    use_jit = (backend in ("cuda", "rocm")) or (sim.steps >= 20)
    if use_jit:
        return _train_step_jit(policy_params, opt_state, mapstate, states0, key, sim)
    else:
        return _train_step_impl(policy_params, opt_state, mapstate, states0, key, sim)


def main():
    # Prefer to place initial arrays directly on GPU if available
    dev = _pick_first_device()
    with jax.default_device(dev):
        key = jax.random.PRNGKey(0)
        mapstate = init_live_map(key)

        # two drones
        def init_state(i):
            p = jnp.array([0., 0.9 * i, 1.6]); v = jnp.zeros(3); q = jnp.array([1., 0., 0., 0.]); w = jnp.zeros(3)
            return State(p, v, q, w)
        states0 = jax.vmap(init_state)(jnp.arange(2))

        # policy net (no CNN/BEV embed; we use fixed features)
        obs_dim = 3 + 3 + 3 + ANCHOR_FEAT_DIM + COMPASS_M + 3  # p, v, fwd, anchors, compass bins, compass vec
        policy_params = init_mlp(jax.random.PRNGKey(2), [obs_dim, 64, 64, 6])  # -> [ax,ay,az,wx,wy,wz]
        opt_state = POLICY_OPT.init(policy_params)

    sim = SimCfg()

    # Warm-up compile or first run
    print("Compiling… (or running eager on CPU small run)")
    key, sub = jax.random.split(key)
    policy_params, opt_state, mapstate, loss, metrics = train_step(
        policy_params, opt_state, mapstate, states0, sub, sim
    )

    # Training loop (host logs tiny scalars)
    for it in range(1, 401):
        key, sub = jax.random.split(key)
        policy_params, opt_state, mapstate, loss, metrics = train_step(
            policy_params, opt_state, mapstate, states0, sub, sim
        )
        if it % 20 == 0 or it == 1:
            recon = float(metrics["recon"])
            coll = float(metrics["coll"])
            ctrl = float(metrics["ctrl"])
            print(f"[{it:03d}] loss={float(loss):.4f} | recon={recon:.3f} | coll={coll:.3f} | ctrl={ctrl:.3f}")


if __name__ == "__main__":
    main()

```

## live_mvp\src\live_mvp\__init__.py

```python

```

## live_mvp\src\live_mvp\__pycache__\dyn.cpython-311.pyc

```pyc
[Binary file content not included]
```

## live_mvp\src\live_mvp\__pycache__\env_gt.cpython-311.pyc

```pyc
[Binary file content not included]
```

## live_mvp\src\live_mvp\__pycache__\live_map.cpython-311.pyc

```pyc
[Binary file content not included]
```

## live_mvp\src\live_mvp\__pycache__\play_interactive.cpython-311.pyc

```pyc
[Binary file content not included]
```

## live_mvp\src\live_mvp\__pycache__\play_interactive_3d.cpython-311.pyc

```pyc
[Binary file content not included]
```

## live_mvp\src\live_mvp\__pycache__\policy.cpython-311.pyc

```pyc
[Binary file content not included]
```

## live_mvp\src\live_mvp\__pycache__\render.cpython-311.pyc

```pyc
[Binary file content not included]
```

## live_mvp\src\live_mvp\__pycache__\train_live.cpython-311.pyc

```pyc
[Binary file content not included]
```

## live_mvp\src\live_mvp\__pycache__\__init__.cpython-311.pyc

```pyc
[Binary file content not included]
```

## live_mvp\src\live_mvp.egg-info\dependency_links.txt

```txt


```

## live_mvp\src\live_mvp.egg-info\PKG-INFO

```egg-info\pkg-info
Metadata-Version: 2.4
Name: live_mvp
Version: 0.1.0
Summary: Minimal live-map + policy demo (hash-grid, anchor + compass)
Author: live_mvp authors
Requires-Python: >=3.10
Description-Content-Type: text/markdown


# live_mvp — Minimal live-map + policy (hash-grid, anchor + compass)

This is a tiny, end-to-end differentiable multi-drone scanning demo. The **only** ground-truth usage is to synthesize depth; **everything** the policy sees and all rewards come from a **live map** learned online:

- `Gθ(x)`: geometry SDF (via a tiny MLP on a **multi‑resolution hash‑grid** encoder)
- `Qη(x)`: exposure/coverage ∈ [0,1] (same encoder family)

**Policy inputs (no learned featurizer):**
- **Anchor‑lattice** samples of `[clipped SDF, exposure]` at a small 3D grid around the drone (captures vertical structure / altitude cues).
- An **“unseen compass”**: per‑direction info‑gain–like potentials from the live map, plus a summarized 3‑vector pointing toward unseen space.

**Differentiable where it matters:** Gradients flow from reward → pose via soft visibility; we **do not** backprop through live-map parameters (map updates are SGD steps with stop‑grad exposure).

---

## Install & run

> **Windows + GPU note:** Native Windows GPU wheels for JAX are not supported; use **WSL2 (Ubuntu)** for GPU, or install the CPU-only environment on Windows. See `install_wsl_gpu.sh` and `install_windows_cpu.bat` in the `scripts/` folder.

```bash
# In WSL2 (GPU) or Linux:
bash scripts/install_wsl_gpu.sh
# Then
python -m live_mvp.train_live
```

On Windows CPU-only:
```bat
scripts\install_windows_cpu.bat
# Then (in Anaconda Prompt or VS Code with that env selected):
python -m live_mvp.train_live
```

---

## What’s inside

- `env_gt.py` : Analytic GT world (plane + sphere + box) & sphere-traced depth.
- `live_map.py`: Hash‑grid encoders + tiny MLPs for `Gθ` and `Qη`; **masked** online updates.
- `render.py`  : Soft visibility, expected hit, incidence, reward terms.
- `dyn.py`     : Simple differentiable kinematics & quaternion utilities.
- `policy.py`  : Non‑learned **anchor‑lattice** and **unseen compass** features, and a tiny MLP for the policy.
- `train_live.py`: Fused `train_step` (JIT/GPU); rollout loop that updates the live map, computes reward **from the live map**, and trains the policy.

```

## live_mvp\src\live_mvp.egg-info\SOURCES.txt

```txt
README.md
pyproject.toml
src/live_mvp/__init__.py
src/live_mvp/dyn.py
src/live_mvp/env_gt.py
src/live_mvp/live_map.py
src/live_mvp/policy.py
src/live_mvp/render.py
src/live_mvp/train_live.py
src/live_mvp.egg-info/PKG-INFO
src/live_mvp.egg-info/SOURCES.txt
src/live_mvp.egg-info/dependency_links.txt
src/live_mvp.egg-info/top_level.txt
tests/test_00_import.py
tests/test_10_env_gt.py
tests/test_20_rollout_smoke.py
```

## live_mvp\src\live_mvp.egg-info\top_level.txt

```txt
live_mvp

```

## live_mvp\tests\test_00_import.py

```python
def test_imports():
    import jax
    import live_mvp
    assert hasattr(jax, "__version__")

```

## live_mvp\tests\test_10_env_gt.py

```python
import jax.numpy as jnp
from live_mvp.env_gt import raycast_depth_gt, phi_gt


def test_downward_hits_scene_surface_or_inside():
    """
    Full-scene raycast should produce a finite depth for a downward ray.
    We assert the hitpoint is on/inside some surface (phi <= small tol),
    not an exact numeric plane distance.
    """
    o = jnp.array([0., 0., 1.5]); d = jnp.array([0., 0., -1.])
    t = raycast_depth_gt(o, d, t_max=5.0, iters=64)
    assert jnp.isfinite(t)
    x = o + t * d
    assert float(phi_gt(x)) <= 1e-2  # on/inside any surface


def test_parallel_along_x_hits_object():
    """
    A ray parallel to the ground along +x from z=1.5 should hit the sphere/box.
    Old test expected NaN; for the full scene this should be a finite hit.
    """
    o = jnp.array([0., 0., 1.5]); d = jnp.array([1., 0., 0.])
    t = raycast_depth_gt(o, d, t_max=12.0, iters=64)
    assert jnp.isfinite(t)
    x = o + t * d
    assert float(phi_gt(x)) <= 5e-2  # on/inside object surface


def test_upward_miss_returns_nan():
    o = jnp.array([0., 0., 1.5]); d = jnp.array([0., 0., 1.])
    t = raycast_depth_gt(o, d, t_max=12.0, iters=64)
    assert jnp.isnan(t)

```

## live_mvp\tests\test_20_rollout_smoke.py

```python
import jax, jax.numpy as jnp
from live_mvp.train_live import train_step, SimCfg, POLICY_OPT
from live_mvp.live_map import init_live_map
from live_mvp.dyn import State
from live_mvp.policy import init_mlp, ANCHOR_FEAT_DIM, COMPASS_M

def _pick_first_device():
    for backend in ("cuda", "rocm"):
        try:
            devs = jax.devices(backend)
            if devs:
                return devs[0]
        except RuntimeError:
            # backend not present
            pass
    return jax.devices()[0]  # CPU fallback


def test_train_step_smoke():
    dev = _pick_first_device()
    with jax.default_device(dev):
        key = jax.random.PRNGKey(0)
        mapstate = init_live_map(key)
        states0 = State(
            p=jnp.array([[0.,0.,1.6],[0.,0.9,1.6]]),
            v=jnp.zeros((2,3)),
            q=jnp.tile(jnp.array([1.,0.,0.,0.]), (2,1)),
            w=jnp.zeros((2,3)),
        )
        obs_dim = 3 + 3 + 3 + ANCHOR_FEAT_DIM + COMPASS_M + 3
        policy_params = init_mlp(jax.random.PRNGKey(1), [obs_dim, 32, 32, 6])
        opt_state = POLICY_OPT.init(policy_params)
        sim = SimCfg(steps=5)
        policy_params, opt_state, mapstate, loss, metrics = train_step(
            policy_params, opt_state, mapstate, states0, key, sim
        )
        assert jnp.isfinite(loss)
        assert all(jnp.isfinite(jnp.array(list(metrics.values()))))

```

## live_mvp\tests\test_30_env_properties.py

```python
import jax.numpy as jnp
from numpy.testing import assert_allclose
from live_mvp.env_gt import smin, sd_box, phi_gt, raycast_depth_gt


def test_smin_bounds():
    """
    Smooth-min must lie between min(a,b) - ln(2)/k and min(a,b).
    """
    k = 8.0
    pairs = [
        (1.0, 2.0),
        (2.0, 1.0),
        (0.0, -1.0),
        (-2.0, -3.0),
        (10.0, -10.0),
    ]
    for a, b in pairs:
        sm = float(smin(jnp.array(a), jnp.array(b), k))
        mn = min(a, b)
        lower = mn - jnp.log(2.0) / k
        assert sm <= mn + 1e-6
        assert sm >= float(lower) - 1e-6


def test_sd_box_known_points():
    """
    Check exact distances for a few easy box cases.
    """
    h = jnp.array([1.0, 2.0, 3.0])
    # Inside at origin -> -min half-extent (distance to nearest face)
    d0 = float(sd_box(jnp.array([0.0, 0.0, 0.0]), h))
    assert_allclose(d0, -1.0, atol=1e-6)

    # Outside along +x at (2,0,0) with h=(1,1,1) should be +1
    h1 = jnp.array([1.0, 1.0, 1.0])
    d1 = float(sd_box(jnp.array([2.0, 0.0, 0.0]), h1))
    assert_allclose(d1, 1.0, atol=1e-6)

    # On the surface along +z at (0,0,3) with h=(1,2,3) should be 0
    d2 = float(sd_box(jnp.array([0.0, 0.0, 3.0]), h))
    assert_allclose(d2, 0.0, atol=1e-6)


def test_phi_gt_sphere_center_is_minus_radius():
    """
    Scene contains a sphere of radius 1 at (3,0,1).
    Distance at the center should be -1 (inside by radius).
    """
    x = jnp.array([3.0, 0.0, 1.0])
    d = float(phi_gt(x))
    assert_allclose(d, -1.0, atol=1e-6)


def test_raycast_hits_sphere_along_centerline():
    """
    Aim directly from origin-line toward the sphere's center: should hit the sphere,
    and the hit point should be on/inside the surface (phi <= small tol).
    """
    o = jnp.array([0.0, 0.0, 1.5])
    dir_to_center = jnp.array([3.0, 0.0, 1.0]) - o
    d = dir_to_center / (jnp.linalg.norm(dir_to_center) + 1e-9)
    t = raycast_depth_gt(o, d, t_max=12.0, iters=64)
    assert jnp.isfinite(t).item()
    xh = o + t * d
    assert float(phi_gt(xh)) <= 5e-2  # allow small sphere-tracing error


def test_raycast_upward_miss_nan():
    o = jnp.array([0.0, 0.0, 1.5]); d = jnp.array([0.0, 0.0, 1.0])
    t = raycast_depth_gt(o, d, t_max=12.0, iters=64)
    assert jnp.isnan(t).item()

```

## live_mvp\tests\test_35_env_ray_invariants.py

```python
import jax.numpy as jnp
from live_mvp.env_gt import raycast_depth_gt, phi_gt


def test_direction_scale_invariance_hits():
    """raycast_depth_gt should normalize d; scaling d must not change t."""
    o = jnp.array([0., 0., 1.5])
    d = jnp.array([0., 0., -1.])
    t1 = raycast_depth_gt(o, d, t_max=6.0, iters=64)
    t2 = raycast_depth_gt(o, 7.0 * d, t_max=6.0, iters=64)
    assert jnp.isfinite(t1).item() and jnp.isfinite(t2).item()
    assert jnp.allclose(t1, t2, atol=1e-5)


def test_tmax_limits_enforced():
    """If the true hit is beyond t_max, we must get NaN."""
    o = jnp.array([0., 0., 1.5])
    d = jnp.array([0., 0., -1.])
    t = raycast_depth_gt(o, d, t_max=0.4, iters=64)
    assert jnp.isnan(t).item()


def test_finite_intersections_are_within_range():
    """Whenever t is finite, it must be clamped to [0, t_max]."""
    o = jnp.array([0.0, 0.0, 1.5])
    d = jnp.array([1.0, 0.0, 0.0])
    t_max = 12.0
    t = raycast_depth_gt(o, d, t_max=t_max, iters=64)
    if jnp.isfinite(t):
        assert (t >= 0).item() and (t <= t_max + 1e-6).item()


def test_hitpoint_resides_on_or_inside_surface():
    """For a finite t, phi_gt(o + t d) should be ~0 or slightly negative."""
    o = jnp.array([0.0, 0.0, 1.5])
    d = jnp.array([1.0, 0.0, 0.0])
    t = raycast_depth_gt(o, d, t_max=12.0, iters=64)
    if jnp.isfinite(t):
        xh = o + t * d
        assert float(phi_gt(xh)) <= 5e-2

```

## live_mvp\tests\test_40_render_properties.py

```python
import jax, jax.numpy as jnp
from live_mvp.render import expected_hit_live, sdf_to_sigma, RenderCfg
from live_mvp.live_map import init_live_map


def test_sdf_to_sigma_monotone_decreasing():
    eps = 0.18
    # phi1 < phi2 => sigma(phi1) >= sigma(phi2)
    phis = jnp.array([-1.0, -0.5, 0.0, 0.5, 1.0])
    sigmas = sdf_to_sigma(phis, eps)
    # pairwise monotonic check
    for i in range(len(phis) - 1):
        assert sigmas[i] >= sigmas[i + 1] - 1e-9


def test_expected_hit_live_basic_invariants():
    key = jax.random.PRNGKey(0)
    mapstate = init_live_map(key)
    theta = mapstate.geom.theta
    o = jnp.array([0.0, 0.0, 1.2])
    d = jnp.array([1.0, 0.0, -0.1]); d = d / (jnp.linalg.norm(d) + 1e-9)
    rcfg = RenderCfg(S=32)  # keep it light for CPU

    xh, seen, xs, T, alpha = expected_hit_live(o, d, theta, rcfg)
    # shapes
    assert xs.shape[1] == 3
    assert T.shape == alpha.shape == (rcfg.S,)

    # alpha in [0,1], T in (0,1] and non-increasing
    assert jnp.all((alpha >= 0) & (alpha <= 1)).item()
    assert jnp.all((T > 0) & (T <= 1)).item()
    assert jnp.all(T[1:] <= T[:-1] + 1e-9).item()

    # weights sum to ~1 (ignoring tiny numerical error)
    dt = (rcfg.t1 - rcfg.t0) / (rcfg.S - 1 + 1e-9)
    w = (T * alpha); w = w / (w.sum() + 1e-9)
    assert jnp.allclose(w.sum(), 1.0, atol=1e-5)

    # xh must lie on the ray line: (xh - o) parallel to d
    v = xh - o
    cross = jnp.linalg.norm(jnp.cross(v, d))
    assert cross <= 1e-5

```

## live_mvp\tests\test_45_render_incidence_close.py

```python
import jax.numpy as jnp
from numpy.testing import assert_allclose
from live_mvp.render import incidence_weight, close_weight, RenderCfg, recon_reward_for_ray
from live_mvp.live_map import init_live_map


def _cos(deg):
    return jnp.cos(jnp.deg2rad(deg))


def test_incidence_weight_window_prefers_mid_angles():
    rcfg = RenderCfg(theta_min_deg=20.0, theta_max_deg=60.0, tau_theta=0.08)
    # Construct cos_inc values
    w0   = float(incidence_weight(_cos(0.0),  rcfg))   # head-on (outside window)
    w40  = float(incidence_weight(_cos(40.0), rcfg))   # inside window
    w80  = float(incidence_weight(_cos(80.0), rcfg))   # very grazing (outside window)
    assert w40 > w0 + 1e-4
    assert w40 > w80 + 1e-4


def test_close_weight_monotone():
    rcfg = RenderCfg(r0=2.5, tau_r=0.8)
    w_near = float(close_weight(0.5, rcfg))
    w_far  = float(close_weight(5.0, rcfg))
    assert w_near > w_far + 1e-4


def test_recon_reward_direction_scale_invariance():
    """recon_reward_for_ray normalizes d; scaling should not change the value."""
    ms = init_live_map(jnp.array([0, 1], dtype=jnp.uint32))  # cheap key stub
    theta = ms.geom.theta
    eta = ms.expo.eta
    from live_mvp.render import RenderCfg
    rcfg = RenderCfg(S=24)
    o = jnp.array([0., 0., 1.2])
    d = jnp.array([1., 0., -0.2])
    r1 = recon_reward_for_ray(o, d, theta, eta, rcfg)
    r2 = recon_reward_for_ray(o, 3.0 * d, theta, eta, rcfg)
    assert_allclose(r1, r2, atol=1e-5)

```

## live_mvp\tests\test_50_dyn_quat.py

```python
import jax.numpy as jnp
from numpy.testing import assert_allclose
from live_mvp.dyn import quat_mul, quat_normalize, R_from_q, step, State, DynCfg


def random_unit_quat():
    q = jnp.array([0.7, 0.2, -0.3, 0.6])
    return quat_normalize(q)


def test_quat_mul_identity():
    q = random_unit_quat()
    I = jnp.array([1.0, 0.0, 0.0, 0.0])
    assert_allclose(quat_mul(q, I), q, atol=1e-7)
    assert_allclose(quat_mul(I, q), q, atol=1e-7)


def test_rotation_matrix_is_orthonormal_and_det_one():
    q = random_unit_quat()
    R = R_from_q(q)
    I = jnp.eye(3)
    assert_allclose(R @ R.T, I, atol=1e-6)
    det = jnp.linalg.det(R)
    assert_allclose(det, 1.0, atol=1e-5)


def test_step_zero_control_no_change():
    st = State(
        p=jnp.array([1.0, 2.0, 3.0]),
        v=jnp.zeros(3),
        q=jnp.array([1.0, 0.0, 0.0, 0.0]),
        w=jnp.zeros(3),
    )
    u = jnp.zeros(6)
    cfg = DynCfg(dt=0.05)
    st2 = step(st, u, cfg)
    assert_allclose(st2.p, st.p, atol=1e-7)
    assert_allclose(st2.v, st.v, atol=1e-7)
    assert_allclose(st2.q, st.q, atol=1e-7)
    assert_allclose(st2.w, st.w, atol=1e-7)

```

## live_mvp\tests\test_55_dyn_controls.py

```python
import jax.numpy as jnp
from numpy.testing import assert_allclose
from live_mvp.dyn import clamp_u, body_rays_world, R_from_q, State, DynCfg, step


def test_clamp_u_saturates_to_cfg():
    cfg = DynCfg(a_max=3.5, w_max=1.2)
    u_raw = jnp.array([10., -10., 4.,  5., -5., 4.])
    u = clamp_u(u_raw, cfg)
    a, w = u[:3], u[3:]
    assert_allclose(a, jnp.array([3.5, -3.5, 3.5]), atol=1e-6)
    assert_allclose(w, jnp.array([1.2, -1.2, 1.2]), atol=1e-6)


def test_body_rays_world_z_yaw_90deg():
    # 90 deg about z: [cos(45°), 0, 0, sin(45°)]
    q = jnp.array([jnp.sqrt(0.5), 0., 0., jnp.sqrt(0.5)])
    rays_body = jnp.array([[1.,0.,0.], [0.,1.,0.]])
    rays_world = body_rays_world(q, rays_body)
    # x->y, y->-x under +90° z-rotation (right-handed)
    assert_allclose(rays_world[0], jnp.array([0., 1., 0.]), atol=1e-6)
    assert_allclose(rays_world[1], jnp.array([-1., 0., 0.]), atol=1e-6)


def test_step_respects_clamp_bounds():
    st = State(
        p=jnp.zeros(3),
        v=jnp.zeros(3),
        q=jnp.array([1.,0.,0.,0.]),
        w=jnp.zeros(3),
    )
    # Try to command something huge; the integrator should still stay stable
    u_raw = jnp.array([100., 100., 100., 10., 10., 10.])
    st2 = step(st, u_raw, DynCfg(dt=0.05, a_max=3.5, w_max=1.2))
    # Velocity/omega must remain finite and limited by clamp
    assert jnp.all(jnp.isfinite(st2.v)).item()
    assert jnp.all(jnp.isfinite(st2.w)).item()

```

## live_mvp\tests\test_60_live_map_hash.py

```python
import jax, jax.numpy as jnp
from live_mvp.live_map import (
    HASH_CFG, init_hash_tables, _level_res, _hash_ijk, _encode_point,
    init_live_map, G_phi, Q_expo
)


def test_level_res_monotone():
    Ns = [int(_level_res(l, HASH_CFG)) for l in range(HASH_CFG.L)]
    assert all(Ns[i] <= Ns[i + 1] for i in range(len(Ns) - 1))


def test_hash_range_and_encode_shapes():
    key = jax.random.PRNGKey(0)
    tables = init_hash_tables(key, HASH_CFG)
    assert len(tables) == HASH_CFG.L
    for t in tables:
        assert t.shape == (HASH_CFG.T, HASH_CFG.F)

    # hash range
    idx = _hash_ijk(jnp.array([10, 20, 30], dtype=jnp.int32), HASH_CFG.T)
    assert int(idx) >= 0 and int(idx) < HASH_CFG.T

    # encode one point (in-AABB)
    x = jnp.array([0.0, 0.0, 0.0])
    z = _encode_point(tables, x, HASH_CFG)
    assert z.shape == (HASH_CFG.L * HASH_CFG.F,)

    # clamping at borders (below lb and above ub)
    x_lo = HASH_CFG.lb - 10.0
    x_hi = HASH_CFG.ub + 10.0
    z_lo = _encode_point(tables, x_lo, HASH_CFG)
    z_hi = _encode_point(tables, x_hi, HASH_CFG)
    assert jnp.isfinite(z_lo).all().item()
    assert jnp.isfinite(z_hi).all().item()


def test_G_phi_and_Q_range_and_grad():
    key = jax.random.PRNGKey(0)
    ms = init_live_map(key)
    theta = ms.geom.theta
    eta = ms.expo.eta
    x = jnp.array([0.5, -0.4, 0.8])
    g = G_phi(x, theta)
    q = Q_expo(x, eta)
    assert jnp.isfinite(g).item()
    assert (q >= 0).item() and (q <= 1).item()

    # gradient exists and finite
    grad_g = jax.grad(lambda xx: G_phi(xx, theta))(x)
    assert grad_g.shape == (3,)
    assert jnp.isfinite(grad_g).all().item()

```

## live_mvp\tests\test_65_live_map_updates.py

```python
import jax, jax.numpy as jnp
from live_mvp.live_map import init_live_map, MapState, update_geom, update_expo, v_G, v_Q, HASH_CFG


def _geom_loss_preview(theta, hits_xyz, hits_mask, frees_xyz, frees_mask):
    """Mirror the loss structure in update_geom (without optax)."""
    mu = 0.2
    l_hit = 0.0
    if hits_xyz.shape[0] > 0:
        g_hits = v_G(hits_xyz, theta)
        w_hits = hits_mask.astype(jnp.float32)
        l_hit  = (w_hits * (g_hits**2)).sum() / (w_hits.sum() + 1e-6)

    l_free = 0.0
    if frees_xyz.size > 0:
        xs = frees_xyz.reshape(-1,3)
        wm = frees_mask.reshape(-1).astype(jnp.float32)
        g_free = v_G(xs, theta)
        l_free = (wm * (g_free - mu)**2).sum() / (wm.sum() + 1e-6)

    return l_hit + 0.5*l_free


def test_update_geom_respects_masks_no_param_change_when_all_zero():
    key = jax.random.PRNGKey(0)
    ms = init_live_map(key)
    hits = jnp.array([[0.,0.,0.]])           # any point
    frees = jnp.zeros((1, 2, 3))            # shape-compatible
    m_hit = jnp.zeros((1,))                 # mask all zero
    m_free = jnp.zeros((1,2))               # mask all zero

    before = ms.geom.theta
    ms2 = update_geom(ms, hits, m_hit, frees, m_free)
    after = ms2.geom.theta

    # Params identical (opt state may still change, but we compare theta)
    def flat_sum(params):
        return sum([p.sum() for level in params.tables for p in [level]]) + \
               sum([w.sum() + b.sum() for (w,b) in params.mlp])
    assert jnp.allclose(flat_sum(before), flat_sum(after), atol=0.0)


def test_update_geom_reduces_loss_on_sample_set():
    key = jax.random.PRNGKey(1)
    ms = init_live_map(key)

    # A couple of "hits" targets and some frees behind them
    hits = jnp.array([[0., 0., 0.],
                      [1.0, -0.5, 0.2]])
    m_hit = jnp.ones((hits.shape[0],))

    S = 4
    z_offsets = jnp.linspace(0.3, 1.2, S)[:, None] * jnp.array([0., 0., 1.])[None, :]  # (S,3)
    frees = jnp.stack([h + z_offsets for h in hits], axis=0)  # (R,S,3)
    m_free = jnp.ones((hits.shape[0], S))

    before = float(_geom_loss_preview(ms.geom.theta, hits, m_hit, frees, m_free))
    # A few steps of updates should reduce the preview loss
    steps = 6
    state = ms
    for _ in range(steps):
        state = update_geom(state, hits, m_hit, frees, m_free)
    after = float(_geom_loss_preview(state.geom.theta, hits, m_hit, frees, m_free))
    assert after <= before + 1e-6


def test_update_expo_no_change_when_weights_zero():
    key = jax.random.PRNGKey(2)
    ms = init_live_map(key)

    seen_xyz = jnp.zeros((2, 3, 3))
    seen_w   = jnp.zeros((2, 3))
    before_eta = ms.expo.eta
    ms2 = update_expo(ms, seen_xyz, seen_w)
    after_eta = ms2.expo.eta

    def flat_sum_eta(params):
        return sum([p.sum() for level in params.tables for p in [level]]) + \
               sum([w.sum() + b.sum() for (w,b) in params.mlp])
    assert jnp.allclose(flat_sum_eta(before_eta), flat_sum_eta(after_eta), atol=0.0)


def test_update_expo_bce_decreases():
    key = jax.random.PRNGKey(3)
    ms = init_live_map(key)

    # Points in front of the origin at various depths
    pts = jnp.array([[0.5, 0.0, 0.6],
                     [1.0, -0.7, 0.8],
                     [-0.3, 0.4, 1.0],
                     [0.2, -0.3, 1.2]])
    seen_xyz = jnp.tile(pts[None, :, :], (2, 1, 1))  # (R=2,S=4,3)
    seen_w = jnp.ones((2, 4))

    def bce_avg(eta):
        xs = seen_xyz.reshape(-1,3)
        p  = jax.vmap(lambda x: jax.nn.sigmoid(x))(jnp.array([0.0]))  # stub to keep jax import used
        q  = jax.vmap(lambda x: jnp.clip( jax.nn.sigmoid(0.0) + 0.0 , 0.0, 1.0))(xs)  # not used; silence linters
        # real predictions:
        pred = jax.vmap(lambda x: jnp.clip( jax.nn.sigmoid(0.0)+0.0, 0,1 ))(jnp.array([0.0]))  # unused
        # Use model:
        from live_mvp.live_map import v_Q
        prob = v_Q(xs, eta)
        eps = 1e-6
        bce = -(jnp.log(prob + eps)).mean()
        return float(bce)

    b_before = bce_avg(ms.expo.eta)
    state = ms
    for _ in range(10):
        state = update_expo(state, seen_xyz, seen_w)
    b_after = bce_avg(state.expo.eta)
    assert b_after <= b_before + 1e-6

```

## live_mvp\tests\test_70_policy_anchor_center.py

```python
import jax, jax.numpy as jnp
from live_mvp.policy import anchor_features, ANCHORS_BODY, ANCHOR_FEAT_DIM
from live_mvp.live_map import init_live_map, G_phi, Q_expo


def test_anchor_features_shape_and_center_matches_model():
    key = jax.random.PRNGKey(0)
    ms = init_live_map(key)
    theta = ms.geom.theta
    eta = ms.expo.eta

    p = jnp.array([0.2, -0.1, 1.3])
    q = jnp.array([1.0, 0.0, 0.0, 0.0])  # identity

    feats = anchor_features(p, q, theta, eta)
    assert feats.shape == (ANCHOR_FEAT_DIM,)

    # The last anchor is the center (include_center=True in ANCHORS_BODY)
    # anchor_features packs [phi_clip, E] per anchor, flattened.
    N = ANCHORS_BODY.shape[0]
    phi_clip_center = feats[2*(N-1) + 0]
    E_center        = feats[2*(N-1) + 1]

    # Ground truth from model:
    phi_raw = G_phi(p, theta)
    phi_clip_gt = jnp.clip(phi_raw, -0.5, 0.5) / 0.5
    E_gt = Q_expo(p, eta)

    assert jnp.allclose(phi_clip_center, phi_clip_gt, atol=1e-6).item()
    assert jnp.allclose(E_center,        E_gt,        atol=1e-6).item()

```

## live_mvp\tests\test_70_policy_features.py

```python
import jax, jax.numpy as jnp
from live_mvp.policy import (
    anchor_grid_body, ANCHORS_BODY, ANCHOR_FEAT_DIM,
    compass_rays_body, COMPASS_BODY, unseen_compass_features
)
from live_mvp.live_map import init_live_map
from live_mvp.dyn import R_from_q


def test_anchor_grid_shapes_and_radii():
    K, H, R = 8, 3, 2.5
    anchors = anchor_grid_body(K=K, R=R, H=H, z_min=-1.0, z_max=1.0, include_center=True)
    # count = H*K + 1
    assert anchors.shape == (H * K + 1, 3)
    # ring points have ~radius R at each z (excluding center)
    ring = anchors[:-1]
    radii = jnp.linalg.norm(ring[:, :2], axis=1)
    assert jnp.allclose(radii, R, atol=1e-6)


def test_compass_rays_normalized_and_counts():
    n_az, n_el = 16, 4
    D = compass_rays_body(n_az=n_az, n_el=n_el)
    assert D.shape == (n_az * n_el, 3)
    norms = jnp.linalg.norm(D, axis=1)
    assert jnp.allclose(norms, 1.0, atol=1e-6)


def test_unseen_compass_shapes_and_nonneg():
    key = jax.random.PRNGKey(0)
    ms = init_live_map(key)
    theta = ms.geom.theta
    eta = ms.expo.eta
    p = jnp.array([0.0, 0.0, 1.5])
    q = jnp.array([1.0, 0.0, 0.0, 0.0])  # identity
    # sanity: body->world conversion uses R_from_q; COMPASS_BODY is normalized
    R = R_from_q(q)
    assert jnp.allclose(R @ jnp.eye(3), jnp.eye(3), atol=1e-6)

    from live_mvp.render import RenderCfg
    pot, vec = unseen_compass_features(p, q, theta, eta, RenderCfg(S=24))
    # shapes
    assert pot.shape == (COMPASS_BODY.shape[0],)
    assert vec.shape == (3,)
    # non-negative potentials and finite
    assert (pot >= 0).all().item()
    assert jnp.isfinite(pot).all().item()
    assert jnp.isfinite(vec).all().item()

```

## live_mvp\tests\test_90_train_step_determinism.py

```python
import jax, jax.numpy as jnp
from live_mvp.train_live import train_step, SimCfg, POLICY_OPT
from live_mvp.live_map import init_live_map
from live_mvp.dyn import State
from live_mvp.policy import init_mlp, ANCHOR_FEAT_DIM, COMPASS_M


def _mk_inputs():
    key = jax.random.PRNGKey(0)
    mapstate = init_live_map(key)
    states0 = State(
        p=jnp.array([[0., 0., 1.6], [0., 0.9, 1.6]]),
        v=jnp.zeros((2, 3)),
        q=jnp.tile(jnp.array([1., 0., 0., 0.]), (2, 1)),
        w=jnp.zeros((2, 3)),
    )
    obs_dim = 3 + 3 + 3 + ANCHOR_FEAT_DIM + COMPASS_M + 3
    params = init_mlp(jax.random.PRNGKey(1), [obs_dim, 32, 32, 6])
    opt_state = POLICY_OPT.init(params)
    sim = SimCfg(steps=3)  # keep small to avoid JIT on CPU
    return key, mapstate, states0, params, opt_state, sim


def test_train_step_deterministic_given_same_inputs():
    key, map1, st1, pp1, opt1, sim = _mk_inputs()
    out1 = train_step(pp1, opt1, map1, st1, key, sim)

    key2, map2, st2, pp2, opt2, sim2 = _mk_inputs()  # fresh but identical
    out2 = train_step(pp2, opt2, map2, st2, key2, sim2)

    # Compare loss and metrics exactly/closely
    _, _, _, loss1, metrics1 = out1
    _, _, _, loss2, metrics2 = out2

    assert jnp.allclose(loss1, loss2, atol=1e-8).item()
    for k in metrics1.keys():
        assert jnp.allclose(metrics1[k], metrics2[k], atol=1e-8).item()

```

## live_mvp\tests\__pycache__\test_00_import.cpython-311-pytest-8.4.1.pyc

```pyc
[Binary file content not included]
```

## live_mvp\tests\__pycache__\test_10_env_gt.cpython-311-pytest-8.4.1.pyc

```pyc
[Binary file content not included]
```

## live_mvp\tests\__pycache__\test_20_rollout_smoke.cpython-311-pytest-8.4.1.pyc

```pyc
[Binary file content not included]
```

## live_mvp\tests\__pycache__\test_30_env_properties.cpython-311-pytest-8.4.1.pyc

```pyc
[Binary file content not included]
```

## live_mvp\tests\__pycache__\test_35_env_ray_invariants.cpython-311-pytest-8.4.1.pyc

```pyc
[Binary file content not included]
```

## live_mvp\tests\__pycache__\test_40_render_properties.cpython-311-pytest-8.4.1.pyc

```pyc
[Binary file content not included]
```

## live_mvp\tests\__pycache__\test_45_render_incidence_close.cpython-311-pytest-8.4.1.pyc

```pyc
[Binary file content not included]
```

## live_mvp\tests\__pycache__\test_50_dyn_quat.cpython-311-pytest-8.4.1.pyc

```pyc
[Binary file content not included]
```

## live_mvp\tests\__pycache__\test_55_dyn_controls.cpython-311-pytest-8.4.1.pyc

```pyc
[Binary file content not included]
```

## live_mvp\tests\__pycache__\test_60_live_map_hash.cpython-311-pytest-8.4.1.pyc

```pyc
[Binary file content not included]
```

## live_mvp\tests\__pycache__\test_65_live_map_updates.cpython-311-pytest-8.4.1.pyc

```pyc
[Binary file content not included]
```

## live_mvp\tests\__pycache__\test_70_policy_anchor_center.cpython-311-pytest-8.4.1.pyc

```pyc
[Binary file content not included]
```

## live_mvp\tests\__pycache__\test_70_policy_features.cpython-311-pytest-8.4.1.pyc

```pyc
[Binary file content not included]
```

## live_mvp\tests\__pycache__\test_90_train_step_determinism.cpython-311-pytest-8.4.1.pyc

```pyc
[Binary file content not included]
```
